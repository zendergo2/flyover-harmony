// This file was generated by libdot/bin/concat.
// It has been marked read-only for your safety.  Rather than
// edit it directly, please modify one of these source files.
//
// libdot/js/lib.js
// libdot/js/lib_polyfill.js
// libdot/js/lib_codec.js
// libdot/js/lib_colors.js
// libdot/js/lib_event.js
// libdot/js/lib_f.js
// libdot/js/lib_i18n.js
// libdot/js/lib_message_manager.js
// libdot/js/lib_preference_manager.js
// libdot/js/lib_resource.js
// libdot/js/lib_storage.js
// libdot/js/lib_storage_chrome.js
// libdot/js/lib_storage_local.js
// libdot/js/lib_storage_memory.js
// libdot/js/lib_storage_terminal_private.js

'use strict';

// SOURCE FILE: libdot/js/lib.js
// Copyright 2012 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

const lib = {};

/**
 * Verify |condition| is truthy else throw Error.
 *
 * This function is primarily for satisfying the JS compiler and should be
 * used only when you are certain that your condition is true.  The function is
 * designed to have a version that throws Errors in tests if condition fails,
 * and a nop version for production code.  It configures itself the first time
 * it runs.
 *
 * @param {boolean} condition A condition to check.
 * @closurePrimitive {asserts.truthy}
 */
lib.assert = function(condition) {
  if (globalThis.chai) {
    lib.assert = globalThis.chai.assert;
  } else {
    lib.assert = function(condition) {};
  }
  lib.assert(condition);
};

/**
 * Verify |value| is not null and return |value| if so, else throw Error.
 * See lib.assert.
 *
 * @template T
 * @param {T} value A value to check for null.
 * @return {T} A non-null |value|.
 * @closurePrimitive {asserts.truthy}
 */
lib.notNull = function(value) {
  lib.assert(value !== null);
  return value;
};

/**
 * Verify |value| is not undefined and return |value| if so, else throw Error.
 * See lib.assert.
 *
 * @template T
 * @param {T} value A value to check for null.
 * @return {T} A non-undefined |value|.
 * @closurePrimitive {asserts.truthy}
 */
lib.notUndefined = function(value) {
  lib.assert(value !== undefined);
  return value;
};
// SOURCE FILE: libdot/js/lib_polyfill.js
// Copyright 2017 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Polyfills for ES2020+ features we want to use.
 * @suppress {duplicate} This file redefines many functions.
 */

/** @const */
lib.polyfill = {};
// SOURCE FILE: libdot/js/lib_codec.js
// Copyright 2018 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

lib.codec = {};

/**
 * Join an array of code units to a string.
 *
 * The code units must not be larger than 65535.  The individual code units may
 * be for UTF-8 or UTF-16 -- it doesn't matter since UTF-16 can handle all UTF-8
 * code units.
 *
 * The input array type may be an Array or a typed Array (e.g. Uint8Array).
 *
 * @param {!Uint8Array|!Array<number>} array The code units to generate for
 *     the string.
 * @return {string} A UTF-16 encoded string.
 */
lib.codec.codeUnitArrayToString = function(array) {
  // String concat is faster than Array.join.
  //
  // String.fromCharCode.apply is faster than this if called less frequently
  // and with smaller array sizes (like <32K).  But it's a recursive call so
  // larger arrays will blow the stack and fail.  We also seem to be faster
  // (or at least more constant time) when called frequently.
  let ret = '';
  for (let i = 0; i < array.length; ++i) {
    ret += String.fromCharCode(array[i]);
  }
  return ret;
};

/**
 * Create an array of code units from a UTF-16 encoded string.
 *
 * @param {string} str The string to extract code units from.
 * @param {!ArrayBufferView=} ret The buffer to hold the result.  If not set, a
 *     new Uint8Array is created.
 * @return {!ArrayBufferView} The array of code units.
 */
lib.codec.stringToCodeUnitArray = function(
    str, ret = new Uint8Array(str.length)) {
  // Indexing string directly is faster than Array.map.
  for (let i = 0; i < str.length; ++i) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
};
// SOURCE FILE: libdot/js/lib_colors.js
// Copyright 2012 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for color utilities.
 */
lib.colors = {};

/**
 * First, some canned regular expressions we're going to use in this file.
 *
 *
 *                              BRACE YOURSELF
 *
 *                                 ,~~~~.
 *                                 |>_< ~~
 *                                3`---'-/.
 *                                3:::::\v\
 *                               =o=:::::\,\
 *                                | :::::\,,\
 *
 *                        THE REGULAR EXPRESSIONS
 *                               ARE COMING.
 *
 * There's no way to break long RE literals in JavaScript.  Fix that why don't
 * you?  Oh, and also there's no way to write a string that doesn't interpret
 * escapes.
 *
 * Instead, we stoop to this .replace() trick.
 */
lib.colors.re_ = {
  // CSS hex color, #RGB or RGBA.
  hex16: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,

  // CSS hex color, #RRGGBB or #RRGGBBAA.
  hex24: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,

  // CSS rgb color, rgb(rrr,ggg,bbb).
  rgb: new RegExp(
      ('^/s*rgb/s*/(/s*(/d{1,3})/s*,/s*(/d{1,3})/s*,' +
       '/s*(/d{1,3})/s*/)/s*$'
       ).replace(/\//g, '\\'), 'i'),

  // CSS rgb color, rgba(rrr,ggg,bbb,aaa).
  rgba: new RegExp(
      ('^/s*rgba/s*' +
       '/(/s*(/d{1,3})/s*,/s*(/d{1,3})/s*,/s*(/d{1,3})/s*' +
       '(?:,/s*(/d+(?:/./d+)?)/s*)/)/s*$'
       ).replace(/\//g, '\\'), 'i'),

  // Either RGB or RGBA.
  rgbx: new RegExp(
      ('^/s*rgba?/s*' +
       '/(/s*(/d{1,3})/s*,/s*(/d{1,3})/s*,/s*(/d{1,3})/s*' +
       '(?:,/s*(/d+(?:/./d+)?)/s*)?/)/s*$'
       ).replace(/\//g, '\\'), 'i'),

  // CSS hsl color, hsl(hhh,sss%,lll%).
  hsl: new RegExp(
      ('^/s*hsl/s*' +
       '/(/s*(/d{1,3})/s*,/s*(/d{1,3})/s*%/s*,/s*(/d{1,3})/s*%/s*/)/s*$'
       ).replace(/\//g, '\\'), 'i'),

  // CSS hsl color, hsla(hhh,sss%,lll%,aaa).
  hsla: new RegExp(
      ('^/s*hsla/s*' +
       '/(/s*(/d{1,3})/s*,/s*(/d{1,3})/s*%/s*,/s*(/d{1,3})/s*%/s*' +
       '(?:,/s*(/d+(?:/./d+)?)/s*)/)/s*$'
       ).replace(/\//g, '\\'), 'i'),

  // Either HSL or HSLA.
  hslx: new RegExp(
      ('^/s*hsla?/s*' +
       '/(/s*(/d{1,3})/s*,/s*(/d{1,3})/s*%/s*,/s*(/d{1,3})/s*%/s*' +
       '(?:,/s*(/d+(?:/./d+)?)/s*)?/)/s*$'
       ).replace(/\//g, '\\'), 'i'),

  // An X11 "rgb:dddd/dddd/dddd" value.
  x11rgb: /^\s*rgb:([a-f0-9]{1,4})\/([a-f0-9]{1,4})\/([a-f0-9]{1,4})\s*$/i,

  // English color name.
  name: /[a-z][a-z0-9\s]+/,
};

/**
 * Convert a CSS rgb(ddd,ddd,ddd) color value into an X11 color value.
 *
 * Other CSS color values are ignored to ensure sanitary data handling.
 *
 * Each 'ddd' component is a one byte value specified in decimal.
 *
 * @param {string} value The CSS color value to convert.
 * @return {?string} The X11 color value or null if the value could not be
 *     converted.
 */
lib.colors.rgbToX11 = function(value) {
  function scale(v) {
    v = (Math.min(v, 255) * 257).toString(16);
    return lib.f.zpad(v, 4);
  }

  const ary = value.match(lib.colors.re_.rgbx);
  if (!ary) {
    return null;
  }

  return 'rgb:' + scale(ary[1]) + '/' + scale(ary[2]) + '/' + scale(ary[3]);
};

/**
 * Convert a legacy X11 color value into an CSS rgb(...) color value.
 *
 * They take the form:
 * 12 bit: #RGB          -> #R000G000B000
 * 24 bit: #RRGGBB       -> #RR00GG00BB00
 * 36 bit: #RRRGGGBBB    -> #RRR0GGG0BBB0
 * 48 bit: #RRRRGGGGBBBB
 * These are the most significant bits.
 *
 * Truncate values back down to 24 bit since that's all CSS supports.
 *
 * @param {string} v The X11 hex color value to convert.
 * @return {?string} The CSS color value or null if the value could not be
 *     converted.
 */
lib.colors.x11HexToCSS = function(v) {
  if (!v.startsWith('#')) {
    return null;
  }
  // Strip the leading # off.
  v = v.substr(1);

  // Reject unknown sizes.
  if ([3, 6, 9, 12].indexOf(v.length) == -1) {
    return null;
  }

  // Reject non-hex values.
  if (v.match(/[^a-f0-9]/i)) {
    return null;
  }

  // Split the colors out.
  const size = v.length / 3;
  const r = v.substr(0, size);
  const g = v.substr(size, size);
  const b = v.substr(size + size, size);

  // Normalize to 16 bits.
  function norm16(v) {
    v = parseInt(v, 16);
    return size == 2 ? v :         // 16 bit
           size == 1 ? v << 4 :    // 8 bit
           v >> (4 * (size - 2));  // 24 or 32 bit
  }
  return lib.colors.arrayToRGBA([r, g, b].map(norm16));
};

/**
 * Convert an X11 color value into an CSS rgb(...) color value.
 *
 * The X11 value may be an X11 color name, or an RGB value of the form
 * rgb:hhhh/hhhh/hhhh.  If a component value is less than 4 digits it is
 * padded out to 4, then scaled down to fit in a single byte.
 *
 * @param {string} v The X11 color value to convert.
 * @return {?string} The CSS color value or null if the value could not be
 *     converted.
 */
lib.colors.x11ToCSS = function(v) {
  function scale(v) {
    // Pad out values with less than four digits.  This padding (probably)
    // matches xterm.  It's difficult to say for sure since xterm seems to
    // arrive at a padded value and then perform some combination of
    // gamma correction, color space transformation, and quantization.

    if (v.length == 1) {
      // Single digits pad out to four by repeating the character.  "f" becomes
      // "ffff".  Scaling down a hex value of this pattern by 257 is the same
      // as cutting off one byte.  We skip the middle step and just double
      // the character.
      return parseInt(v + v, 16);
    }

    if (v.length == 2) {
      // Similar deal here.  X11 pads two digit values by repeating the
      // byte (or scale up by 257).  Since we're going to scale it back
      // down anyway, we can just return the original value.
      return parseInt(v, 16);
    }

    if (v.length == 3) {
      // Three digit values seem to be padded by repeating the final digit.
      // e.g. 10f becomes 10ff.
      v = v + v.substr(2);
    }

    // Scale down the 2 byte value.
    return Math.round(parseInt(v, 16) / 257);
  }

  const ary = v.match(lib.colors.re_.x11rgb);
  if (!ary) {
    // Handle the legacy format.
    if (v.startsWith('#')) {
      return lib.colors.x11HexToCSS(v);
    } else {
      return lib.colors.nameToRGB(v);
    }
  }

  ary.splice(0, 1);
  return lib.colors.arrayToRGBA(ary.map(scale));
};

/**
 * Converts one or more CSS '#RRGGBB' or '#RRGGBBAA' color values into their
 * rgb(...) or rgba(...) form respectively.
 *
 * Arrays are converted in place. If a value cannot be converted, it is
 * replaced with null.
 *
 * @param {string} hex A single RGB or RGBA value to convert.
 * @return {?string} The converted value.
 */
lib.colors.hexToRGB = function(hex) {
  const hex16 = lib.colors.re_.hex16;
  const hex24 = lib.colors.re_.hex24;

  if (hex16.test(hex)) {
    // Convert from RGB to RRGGBB and from RGBA to RRGGBBAA.
    hex = `#${hex.match(/[a-f0-9]/gi).map((x) => `${x}${x}`).join('')}`;
  }

  const ary = hex.match(hex24);
  if (!ary) {
    return null;
  }

  const val = (index) => parseInt(ary[index + 1], 16);
  return ary[4] === undefined || val(3) === 255
      ? `rgb(${val(0)}, ${val(1)}, ${val(2)})`
      : `rgba(${val(0)}, ${val(1)}, ${val(2)}, ${val(3) / 255})`;
};

/**
 * Converts one or more CSS rgb(...) or rgba(...) forms into their '#RRGGBB' or
 * '#RRGGBBAA' color values respectively.
 *
 * Arrays are converted in place. If a value cannot be converted, it is
 * replaced with null.
 *
 * @param {string} rgb A single rgb(...) or rgba(...) value to convert.
 * @return {?string} The converted value.
 */
lib.colors.rgbToHex = function(rgb) {
  const ary = lib.colors.crackRGB(rgb);
  if (!ary) {
    return null;
  }

  const hex = '#' + lib.f.zpad((
      (parseInt(ary[0], 10) << 16) |
      (parseInt(ary[1], 10) << 8) |
      (parseInt(ary[2], 10) << 0)).toString(16), 6);
  if (ary[3] === undefined || ary[3] === '1') {
    return hex;
  } else {
    const alpha = Math.round(255 * parseFloat(ary[3])).toString(16);
    return `${hex}${lib.f.zpad(alpha, 2)}`;
  }
};

/**
 * Split an hsl/hsla color into an array of its components.
 *
 * On success, a 4 element array will be returned.  For hsl values, the alpha
 * will be set to 1.
 *
 * @param {string} color The HSL/HSLA CSS color spec.
 * @return {?Array<string>} The HSL/HSLA values split out.
 */
lib.colors.crackHSL = function(color) {
  if (color.startsWith('hsla')) {
    const ary = color.match(lib.colors.re_.hsla);
    if (ary) {
      ary.shift();
      return Array.from(ary);
    }
  } else {
    const ary = color.match(lib.colors.re_.hsl);
    if (ary) {
      ary.shift();
      ary.push('1');
      return Array.from(ary);
    }
  }

  console.error(`Couldn't crack: ${color}`);
  return null;
};

/**
 * Converts hslx array to rgba array.
 *
 * The returned alpha component defaults to 1 if it isn't present in the input.
 *
 * The returned values are not rounded to preserve precision for computations,
 * so should be rounded before they are used in CSS strings.
 *
 * @param {?Array<string|number>} hslx The HSL or HSLA elements to convert.
 * @return {!Array<number>} The RGBA values.
 */
lib.colors.hslxArrayToRgbaArray = function(hslx) {
  const hue = parseInt(hslx[0], 10) / 60;
  const sat = parseInt(hslx[1], 10) / 100;
  const light = parseInt(hslx[2], 10) / 100;

  // The following algorithm has been adapted from:
  //     https://www.w3.org/TR/css-color-4/#hsl-to-rgb
  const hueToRgb = (t1, t2, hue) => {
    if (hue < 0) {
      hue += 6;
    }
    if (hue >= 6) {
      hue -= 6;
    }

    if (hue < 1) {
      return (t2 - t1) * hue + t1;
    } else if (hue < 3) {
      return t2;
    } else if (hue < 4) {
      return (t2 - t1) * (4 - hue) + t1;
    } else {
      return t1;
    }
  };

  const t2 = light <= 0.5 ? light * (sat + 1) : light + sat - (light * sat);
  const t1 = light * 2 - t2;

  return [
    255 * hueToRgb(t1, t2, hue + 2),
    255 * hueToRgb(t1, t2, hue),
    255 * hueToRgb(t1, t2, hue - 2),
    hslx[3] !== undefined ? +hslx[3] : 1,
  ];
};

/**
 * Converts a hsvx array to a hsla array. The hsvx array is an array of [hue
 * (>=0, <=360), saturation (>=0, <=100), value (>=0, <=100), alpha] (alpha can
 * be missing).
 *
 * The returned alpha component defaults to 1 if it isn't present in the input.
 *
 * The returned values are not rounded to preserve precision for computations,
 * so should be rounded before they are used in CSS strings.
 *
 * @param {?Array<string|number>} hsvx The hsv or hsva array.
 * @return {!Array<number>} The hsla array.
 */
lib.colors.hsvxArrayToHslaArray = function(hsvx) {
  const clamp = (x) => lib.f.clamp(x, 0, 100);
  const [hue, saturation, value] = hsvx.map(parseFloat);
  const hslLightness = clamp(value * (100 - saturation / 2) / 100);
  let hslSaturation = 0;
  if (hslLightness !== 0 && hslLightness !== 100) {
    hslSaturation = clamp((value - hslLightness) /
        Math.min(hslLightness, 100 - hslLightness) * 100);
  }
  return [
      hue,
      hslSaturation,
      hslLightness,
      hsvx.length === 4 ? +hsvx[3] : 1,
  ];
};

/**
 * Converts a hslx array to a hsva array. The hsva array is an array of [hue
 * (>=0, <=360), saturation (>=0, <=100), value (>=0, <=100), alpha].
 *
 * The returned alpha component defaults to 1 if it isn't present in the input.
 *
 * @param {?Array<string|number>} hslx The hsl or hsla array.
 * @return {!Array<number>} The hsva array.
 */
lib.colors.hslxArrayToHsvaArray = function(hslx) {
  const clamp = (x) => lib.f.clamp(x, 0, 100);
  const [hue, saturation, lightness] = hslx.map(parseFloat);
  const hsvValue = clamp(
      lightness + saturation * Math.min(lightness, 100 - lightness) / 100);
  let hsvSaturation = 0;
  if (hsvValue !== 0) {
    hsvSaturation = clamp(200 * (1 - lightness / hsvValue));
  }
  return [hue, hsvSaturation, hsvValue, hslx.length === 4 ? +hslx[3] : 1];
};

/**
 * Converts one or more CSS hsl(...) or hsla(...) forms into their rgb(...) or
 * rgba(...) color values respectively.
 *
 * Arrays are converted in place. If a value cannot be converted, it is
 * replaced with null.
 *
 * @param {string} hsl A single hsl(...) or hsla(...) value to convert.
 * @return {?string} The converted value.
 */
lib.colors.hslToRGB = function(hsl) {
  const ary = lib.colors.crackHSL(hsl);
  if (!ary) {
    return null;
  }

  const [r, g, b, a] = lib.colors.hslxArrayToRgbaArray(ary);

  const rgb = [r, g, b].map(Math.round).join(', ');

  return a === 1 ? `rgb(${rgb})` : `rgba(${rgb}, ${a})`;
};

/**
 * Converts rgbx array to hsla array.
 *
 * The returned alpha component defaults to 1 if it isn't present in the input.
 *
 * The returned values are not rounded to preserve precision for computations,
 * so should be rounded before they are used in CSS strings.
 *
 * @param {?Array<string|number>} rgbx The RGB or RGBA elements to convert.
 * @return {!Array<number>} The HSLA values.
 */
lib.colors.rgbxArrayToHslaArray = function(rgbx) {
  const r = parseInt(rgbx[0], 10) / 255;
  const g = parseInt(rgbx[1], 10) / 255;
  const b = parseInt(rgbx[2], 10) / 255;

  const min = Math.min(r, g, b);
  const max = Math.max(r, g, b);
  const spread = max - min;

  /* eslint-disable id-denylist */
  const l = (max + min) / 2;

  if (spread == 0) {
    return [0, 0, 100 * l, rgbx[3] !== undefined ? +rgbx[3] : 1];
  }

  let h = (() => {
    switch (max) {
      case r: return ((g - b) / spread) % 6;
      case g: return (b - r) / spread + 2;
      case b: return (r - g) / spread + 4;
    }
  })();
  h *= 60;
  if (h < 0) {
    h += 360;
  }

  const s = spread / (1 - Math.abs(2 * l - 1));

  return [h, 100 * s, 100 * l, rgbx[3] !== undefined ? +rgbx[3] : 1];
  /* eslint-enable id-denylist */
};

/**
 * Converts one or more CSS rgb(...) or rgba(...) forms into their hsl(...) or
 * hsla(...) color values respectively.
 *
 * Arrays are converted in place. If a value cannot be converted, it is
 * replaced with null.
 *
 * @param {string} rgb A single rgb(...) or rgba(...) value to convert.
 * @return {?string} The converted value.
 */
lib.colors.rgbToHsl = function(rgb) {
  const ary = lib.colors.crackRGB(rgb);
  if (!ary) {
    return null;
  }

  /* eslint-disable id-denylist */
  // eslint-disable-next-line prefer-const
  let [h, s, l, a] = lib.colors.rgbxArrayToHslaArray(ary);
  h = Math.round(h);
  s = Math.round(s);
  l = Math.round(l);

  return a === 1 ? `hsl(${h}, ${s}%, ${l}%)` : `hsla(${h}, ${s}%, ${l}%, ${a})`;
  /* eslint-enable id-denylist */
};

/**
 * Take any valid CSS color definition and turn it into an rgb or rgba value.
 *
 * @param {string} def The CSS color spec to normalize.
 * @return {?string} The converted value.
 */
lib.colors.normalizeCSS = function(def) {
  if (def.startsWith('#')) {
    return lib.colors.hexToRGB(def);
  }

  if (lib.colors.re_.rgbx.test(def)) {
    return def;
  }

  if (lib.colors.re_.hslx.test(def)) {
    return lib.colors.hslToRGB(def);
  }

  return lib.colors.nameToRGB(def);
};

/**
 * Take any valid CSS color definition and turn it into an hsl or hsla value.
 *
 * @param {string} def The CSS color spec to normalize.
 * @return {?string} The converted value.
 */
lib.colors.normalizeCSSToHSL = function(def) {
  if (lib.colors.re_.hslx.test(def)) {
    return def;
  }

  const rgb = lib.colors.normalizeCSS(def);
  if (!rgb) {
    return rgb;
  }
  return lib.colors.rgbToHsl(rgb);
};

/**
 * Convert a 3 or 4 element array into an rgb(...) or rgba(...) string.
 *
 * @param {?Array<string|number>} ary The RGB or RGBA elements to convert.
 * @return {string} The normalized CSS color spec.
 */
lib.colors.arrayToRGBA = function(ary) {
  if (ary.length == 3) {
    return `rgb(${ary[0]}, ${ary[1]}, ${ary[2]})`;
  }
  return `rgba(${ary[0]}, ${ary[1]}, ${ary[2]}, ${ary[3]})`;
};

/**
 * Convert a 3 or 4 element array into an hsla(...) string.
 *
 * @param {?Array<string|number>} ary The HSL or HSLA elements to convert.
 * @return {string} The normalized CSS color spec.
 */
lib.colors.arrayToHSLA = function(ary) {
  const alpha = (ary.length > 3) ? ary[3] : 1;
  return `hsla(${Math.round(ary[0])}, ${Math.round(ary[1])}%, ` +
      `${Math.round(ary[2])}%, ${alpha})`;
};

/**
 * Overwrite the alpha channel of an rgb/rgba color.
 *
 * @param {string} rgb The normalized CSS color spec.
 * @param {number} alpha The alpha channel.
 * @return {string} The normalized CSS color spec with updated alpha channel.
 */
lib.colors.setAlpha = function(rgb, alpha) {
  const ary = lib.colors.crackRGB(rgb);
  ary[3] = alpha.toString();
  return lib.colors.arrayToRGBA(ary);
};

/**
 * Mix a percentage of a tint color into a base color.
 *
 * @param  {string} base The normalized CSS base color spec.
 * @param  {string} tint The normalized CSS color to tint with.
 * @param  {number} percent The percentage of the tinting.
 * @return {string} The new tinted CSS color spec.
 */
lib.colors.mix = function(base, tint, percent) {
  const ary1 = lib.colors.crackRGB(base);
  const ary2 = lib.colors.crackRGB(tint);

  for (let i = 0; i < 4; ++i) {
    const basecol = parseInt(ary1[i], 10);
    const tintcol = parseInt(ary2[i], 10);
    const diff = tintcol - basecol;
    ary1[i] = Math.round(base + diff * percent).toString();
  }

  return lib.colors.arrayToRGBA(ary1);
};

/**
 * Split an rgb/rgba color into an array of its components.
 *
 * On success, a 4 element array will be returned.  For rgb values, the alpha
 * will be set to 1.
 *
 * @param {string} color The RGB/RGBA CSS color spec.
 * @return {?Array<string>} The RGB/RGBA values split out.
 */
lib.colors.crackRGB = function(color) {
  if (color.startsWith('rgba')) {
    const ary = color.match(lib.colors.re_.rgba);
    if (ary) {
      ary.shift();
      return Array.from(ary);
    }
  } else {
    const ary = color.match(lib.colors.re_.rgb);
    if (ary) {
      ary.shift();
      ary.push('1');
      return Array.from(ary);
    }
  }

  console.error('Couldn\'t crack: ' + color);
  return null;
};

/**
 * Convert an X11 color name into a CSS rgb(...) value.
 *
 * Names are stripped of spaces and converted to lowercase.  If the name is
 * unknown, null is returned.
 *
 * This list of color name to RGB mapping is derived from the stock X11
 * rgb.txt file.
 *
 * @param {string} name The color name to convert.
 * @return {?string} The corresponding CSS rgb(...) value.
 */
lib.colors.nameToRGB = function(name) {
  if (name in lib.colors.colorNames) {
    return lib.colors.colorNames[name];
  }

  name = name.toLowerCase();
  if (name in lib.colors.colorNames) {
    return lib.colors.colorNames[name];
  }

  name = name.replace(/\s+/g, '');
  if (name in lib.colors.colorNames) {
    return lib.colors.colorNames[name];
  }

  return null;
};

/**
 * Calculate the relative luminance as per
 * https://www.w3.org/TR/WCAG20/#relativeluminancedef
 *
 * @param {number} r The value (>=0 and <= 255) of the rgb component.
 * @param {number} g The value (>=0 and <= 255) of the rgb component.
 * @param {number} b The value (>=0 and <= 255) of the rgb component.
 * @return {number} The relative luminance.
 */
lib.colors.luminance = function(r, g, b) {
  const [rr, gg, bb] = [r, g, b].map((value) => {
    value /= 255;
    if (value <= 0.03928) {
      return value / 12.92;
    } else {
      return Math.pow((value + 0.055) / 1.055, 2.4);
    }
  });

  return 0.2126 * rr + 0.7152 * gg + 0.0722 * bb;
};

/**
 * Calculate the contrast ratio of two relative luminance values as per
 * https://www.w3.org/TR/WCAG20/#contrast-ratiodef
 *
 * @param {number} l1 Relative luminance value.
 * @param {number} l2 Relative luminance value.
 * @return {number} The contrast ratio.
 */
lib.colors.contrastRatio = function(l1, l2) {
  return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
};

/**
 * The stock color palette.
 *
 * @type {!Array<string>}
 */
lib.colors.stockPalette = [
     // The "ANSI 16"...
    '#000000', '#CC0000', '#4E9A06', '#C4A000',
    '#3465A4', '#75507B', '#06989A', '#D3D7CF',
    '#555753', '#EF2929', '#00BA13', '#FCE94F',
    '#729FCF', '#F200CB', '#00B5BD', '#EEEEEC',

    // The 6x6 color cubes...
    '#000000', '#00005F', '#000087', '#0000AF', '#0000D7', '#0000FF',
    '#005F00', '#005F5F', '#005F87', '#005FAF', '#005FD7', '#005FFF',
    '#008700', '#00875F', '#008787', '#0087AF', '#0087D7', '#0087FF',
    '#00AF00', '#00AF5F', '#00AF87', '#00AFAF', '#00AFD7', '#00AFFF',
    '#00D700', '#00D75F', '#00D787', '#00D7AF', '#00D7D7', '#00D7FF',
    '#00FF00', '#00FF5F', '#00FF87', '#00FFAF', '#00FFD7', '#00FFFF',

    '#5F0000', '#5F005F', '#5F0087', '#5F00AF', '#5F00D7', '#5F00FF',
    '#5F5F00', '#5F5F5F', '#5F5F87', '#5F5FAF', '#5F5FD7', '#5F5FFF',
    '#5F8700', '#5F875F', '#5F8787', '#5F87AF', '#5F87D7', '#5F87FF',
    '#5FAF00', '#5FAF5F', '#5FAF87', '#5FAFAF', '#5FAFD7', '#5FAFFF',
    '#5FD700', '#5FD75F', '#5FD787', '#5FD7AF', '#5FD7D7', '#5FD7FF',
    '#5FFF00', '#5FFF5F', '#5FFF87', '#5FFFAF', '#5FFFD7', '#5FFFFF',

    '#870000', '#87005F', '#870087', '#8700AF', '#8700D7', '#8700FF',
    '#875F00', '#875F5F', '#875F87', '#875FAF', '#875FD7', '#875FFF',
    '#878700', '#87875F', '#878787', '#8787AF', '#8787D7', '#8787FF',
    '#87AF00', '#87AF5F', '#87AF87', '#87AFAF', '#87AFD7', '#87AFFF',
    '#87D700', '#87D75F', '#87D787', '#87D7AF', '#87D7D7', '#87D7FF',
    '#87FF00', '#87FF5F', '#87FF87', '#87FFAF', '#87FFD7', '#87FFFF',

    '#AF0000', '#AF005F', '#AF0087', '#AF00AF', '#AF00D7', '#AF00FF',
    '#AF5F00', '#AF5F5F', '#AF5F87', '#AF5FAF', '#AF5FD7', '#AF5FFF',
    '#AF8700', '#AF875F', '#AF8787', '#AF87AF', '#AF87D7', '#AF87FF',
    '#AFAF00', '#AFAF5F', '#AFAF87', '#AFAFAF', '#AFAFD7', '#AFAFFF',
    '#AFD700', '#AFD75F', '#AFD787', '#AFD7AF', '#AFD7D7', '#AFD7FF',
    '#AFFF00', '#AFFF5F', '#AFFF87', '#AFFFAF', '#AFFFD7', '#AFFFFF',

    '#D70000', '#D7005F', '#D70087', '#D700AF', '#D700D7', '#D700FF',
    '#D75F00', '#D75F5F', '#D75F87', '#D75FAF', '#D75FD7', '#D75FFF',
    '#D78700', '#D7875F', '#D78787', '#D787AF', '#D787D7', '#D787FF',
    '#D7AF00', '#D7AF5F', '#D7AF87', '#D7AFAF', '#D7AFD7', '#D7AFFF',
    '#D7D700', '#D7D75F', '#D7D787', '#D7D7AF', '#D7D7D7', '#D7D7FF',
    '#D7FF00', '#D7FF5F', '#D7FF87', '#D7FFAF', '#D7FFD7', '#D7FFFF',

    '#FF0000', '#FF005F', '#FF0087', '#FF00AF', '#FF00D7', '#FF00FF',
    '#FF5F00', '#FF5F5F', '#FF5F87', '#FF5FAF', '#FF5FD7', '#FF5FFF',
    '#FF8700', '#FF875F', '#FF8787', '#FF87AF', '#FF87D7', '#FF87FF',
    '#FFAF00', '#FFAF5F', '#FFAF87', '#FFAFAF', '#FFAFD7', '#FFAFFF',
    '#FFD700', '#FFD75F', '#FFD787', '#FFD7AF', '#FFD7D7', '#FFD7FF',
    '#FFFF00', '#FFFF5F', '#FFFF87', '#FFFFAF', '#FFFFD7', '#FFFFFF',

    // The greyscale ramp...
    '#080808', '#121212', '#1C1C1C', '#262626', '#303030', '#3A3A3A',
    '#444444', '#4E4E4E', '#585858', '#626262', '#6C6C6C', '#767676',
    '#808080', '#8A8A8A', '#949494', '#9E9E9E', '#A8A8A8', '#B2B2B2',
    '#BCBCBC', '#C6C6C6', '#D0D0D0', '#DADADA', '#E4E4E4', '#EEEEEE',
   ].map(lib.colors.hexToRGB);

/**
 * Named colors according to the stock X11 rgb.txt file.
 */
lib.colors.colorNames = {
  'aliceblue': 'rgb(240, 248, 255)',
  'antiquewhite': 'rgb(250, 235, 215)',
  'antiquewhite1': 'rgb(255, 239, 219)',
  'antiquewhite2': 'rgb(238, 223, 204)',
  'antiquewhite3': 'rgb(205, 192, 176)',
  'antiquewhite4': 'rgb(139, 131, 120)',
  'aquamarine': 'rgb(127, 255, 212)',
  'aquamarine1': 'rgb(127, 255, 212)',
  'aquamarine2': 'rgb(118, 238, 198)',
  'aquamarine3': 'rgb(102, 205, 170)',
  'aquamarine4': 'rgb(69, 139, 116)',
  'azure': 'rgb(240, 255, 255)',
  'azure1': 'rgb(240, 255, 255)',
  'azure2': 'rgb(224, 238, 238)',
  'azure3': 'rgb(193, 205, 205)',
  'azure4': 'rgb(131, 139, 139)',
  'beige': 'rgb(245, 245, 220)',
  'bisque': 'rgb(255, 228, 196)',
  'bisque1': 'rgb(255, 228, 196)',
  'bisque2': 'rgb(238, 213, 183)',
  'bisque3': 'rgb(205, 183, 158)',
  'bisque4': 'rgb(139, 125, 107)',
  'black': 'rgb(0, 0, 0)',
  'blanchedalmond': 'rgb(255, 235, 205)',
  'blue': 'rgb(0, 0, 255)',
  'blue1': 'rgb(0, 0, 255)',
  'blue2': 'rgb(0, 0, 238)',
  'blue3': 'rgb(0, 0, 205)',
  'blue4': 'rgb(0, 0, 139)',
  'blueviolet': 'rgb(138, 43, 226)',
  'brown': 'rgb(165, 42, 42)',
  'brown1': 'rgb(255, 64, 64)',
  'brown2': 'rgb(238, 59, 59)',
  'brown3': 'rgb(205, 51, 51)',
  'brown4': 'rgb(139, 35, 35)',
  'burlywood': 'rgb(222, 184, 135)',
  'burlywood1': 'rgb(255, 211, 155)',
  'burlywood2': 'rgb(238, 197, 145)',
  'burlywood3': 'rgb(205, 170, 125)',
  'burlywood4': 'rgb(139, 115, 85)',
  'cadetblue': 'rgb(95, 158, 160)',
  'cadetblue1': 'rgb(152, 245, 255)',
  'cadetblue2': 'rgb(142, 229, 238)',
  'cadetblue3': 'rgb(122, 197, 205)',
  'cadetblue4': 'rgb(83, 134, 139)',
  'chartreuse': 'rgb(127, 255, 0)',
  'chartreuse1': 'rgb(127, 255, 0)',
  'chartreuse2': 'rgb(118, 238, 0)',
  'chartreuse3': 'rgb(102, 205, 0)',
  'chartreuse4': 'rgb(69, 139, 0)',
  'chocolate': 'rgb(210, 105, 30)',
  'chocolate1': 'rgb(255, 127, 36)',
  'chocolate2': 'rgb(238, 118, 33)',
  'chocolate3': 'rgb(205, 102, 29)',
  'chocolate4': 'rgb(139, 69, 19)',
  'coral': 'rgb(255, 127, 80)',
  'coral1': 'rgb(255, 114, 86)',
  'coral2': 'rgb(238, 106, 80)',
  'coral3': 'rgb(205, 91, 69)',
  'coral4': 'rgb(139, 62, 47)',
  'cornflowerblue': 'rgb(100, 149, 237)',
  'cornsilk': 'rgb(255, 248, 220)',
  'cornsilk1': 'rgb(255, 248, 220)',
  'cornsilk2': 'rgb(238, 232, 205)',
  'cornsilk3': 'rgb(205, 200, 177)',
  'cornsilk4': 'rgb(139, 136, 120)',
  'cyan': 'rgb(0, 255, 255)',
  'cyan1': 'rgb(0, 255, 255)',
  'cyan2': 'rgb(0, 238, 238)',
  'cyan3': 'rgb(0, 205, 205)',
  'cyan4': 'rgb(0, 139, 139)',
  'darkblue': 'rgb(0, 0, 139)',
  'darkcyan': 'rgb(0, 139, 139)',
  'darkgoldenrod': 'rgb(184, 134, 11)',
  'darkgoldenrod1': 'rgb(255, 185, 15)',
  'darkgoldenrod2': 'rgb(238, 173, 14)',
  'darkgoldenrod3': 'rgb(205, 149, 12)',
  'darkgoldenrod4': 'rgb(139, 101, 8)',
  'darkgray': 'rgb(169, 169, 169)',
  'darkgreen': 'rgb(0, 100, 0)',
  'darkgrey': 'rgb(169, 169, 169)',
  'darkkhaki': 'rgb(189, 183, 107)',
  'darkmagenta': 'rgb(139, 0, 139)',
  'darkolivegreen': 'rgb(85, 107, 47)',
  'darkolivegreen1': 'rgb(202, 255, 112)',
  'darkolivegreen2': 'rgb(188, 238, 104)',
  'darkolivegreen3': 'rgb(162, 205, 90)',
  'darkolivegreen4': 'rgb(110, 139, 61)',
  'darkorange': 'rgb(255, 140, 0)',
  'darkorange1': 'rgb(255, 127, 0)',
  'darkorange2': 'rgb(238, 118, 0)',
  'darkorange3': 'rgb(205, 102, 0)',
  'darkorange4': 'rgb(139, 69, 0)',
  'darkorchid': 'rgb(153, 50, 204)',
  'darkorchid1': 'rgb(191, 62, 255)',
  'darkorchid2': 'rgb(178, 58, 238)',
  'darkorchid3': 'rgb(154, 50, 205)',
  'darkorchid4': 'rgb(104, 34, 139)',
  'darkred': 'rgb(139, 0, 0)',
  'darksalmon': 'rgb(233, 150, 122)',
  'darkseagreen': 'rgb(143, 188, 143)',
  'darkseagreen1': 'rgb(193, 255, 193)',
  'darkseagreen2': 'rgb(180, 238, 180)',
  'darkseagreen3': 'rgb(155, 205, 155)',
  'darkseagreen4': 'rgb(105, 139, 105)',
  'darkslateblue': 'rgb(72, 61, 139)',
  'darkslategray': 'rgb(47, 79, 79)',
  'darkslategray1': 'rgb(151, 255, 255)',
  'darkslategray2': 'rgb(141, 238, 238)',
  'darkslategray3': 'rgb(121, 205, 205)',
  'darkslategray4': 'rgb(82, 139, 139)',
  'darkslategrey': 'rgb(47, 79, 79)',
  'darkturquoise': 'rgb(0, 206, 209)',
  'darkviolet': 'rgb(148, 0, 211)',
  'debianred': 'rgb(215, 7, 81)',
  'deeppink': 'rgb(255, 20, 147)',
  'deeppink1': 'rgb(255, 20, 147)',
  'deeppink2': 'rgb(238, 18, 137)',
  'deeppink3': 'rgb(205, 16, 118)',
  'deeppink4': 'rgb(139, 10, 80)',
  'deepskyblue': 'rgb(0, 191, 255)',
  'deepskyblue1': 'rgb(0, 191, 255)',
  'deepskyblue2': 'rgb(0, 178, 238)',
  'deepskyblue3': 'rgb(0, 154, 205)',
  'deepskyblue4': 'rgb(0, 104, 139)',
  'dimgray': 'rgb(105, 105, 105)',
  'dimgrey': 'rgb(105, 105, 105)',
  'dodgerblue': 'rgb(30, 144, 255)',
  'dodgerblue1': 'rgb(30, 144, 255)',
  'dodgerblue2': 'rgb(28, 134, 238)',
  'dodgerblue3': 'rgb(24, 116, 205)',
  'dodgerblue4': 'rgb(16, 78, 139)',
  'firebrick': 'rgb(178, 34, 34)',
  'firebrick1': 'rgb(255, 48, 48)',
  'firebrick2': 'rgb(238, 44, 44)',
  'firebrick3': 'rgb(205, 38, 38)',
  'firebrick4': 'rgb(139, 26, 26)',
  'floralwhite': 'rgb(255, 250, 240)',
  'forestgreen': 'rgb(34, 139, 34)',
  'gainsboro': 'rgb(220, 220, 220)',
  'ghostwhite': 'rgb(248, 248, 255)',
  'gold': 'rgb(255, 215, 0)',
  'gold1': 'rgb(255, 215, 0)',
  'gold2': 'rgb(238, 201, 0)',
  'gold3': 'rgb(205, 173, 0)',
  'gold4': 'rgb(139, 117, 0)',
  'goldenrod': 'rgb(218, 165, 32)',
  'goldenrod1': 'rgb(255, 193, 37)',
  'goldenrod2': 'rgb(238, 180, 34)',
  'goldenrod3': 'rgb(205, 155, 29)',
  'goldenrod4': 'rgb(139, 105, 20)',
  'gray': 'rgb(190, 190, 190)',
  'gray0': 'rgb(0, 0, 0)',
  'gray1': 'rgb(3, 3, 3)',
  'gray10': 'rgb(26, 26, 26)',
  'gray100': 'rgb(255, 255, 255)',
  'gray11': 'rgb(28, 28, 28)',
  'gray12': 'rgb(31, 31, 31)',
  'gray13': 'rgb(33, 33, 33)',
  'gray14': 'rgb(36, 36, 36)',
  'gray15': 'rgb(38, 38, 38)',
  'gray16': 'rgb(41, 41, 41)',
  'gray17': 'rgb(43, 43, 43)',
  'gray18': 'rgb(46, 46, 46)',
  'gray19': 'rgb(48, 48, 48)',
  'gray2': 'rgb(5, 5, 5)',
  'gray20': 'rgb(51, 51, 51)',
  'gray21': 'rgb(54, 54, 54)',
  'gray22': 'rgb(56, 56, 56)',
  'gray23': 'rgb(59, 59, 59)',
  'gray24': 'rgb(61, 61, 61)',
  'gray25': 'rgb(64, 64, 64)',
  'gray26': 'rgb(66, 66, 66)',
  'gray27': 'rgb(69, 69, 69)',
  'gray28': 'rgb(71, 71, 71)',
  'gray29': 'rgb(74, 74, 74)',
  'gray3': 'rgb(8, 8, 8)',
  'gray30': 'rgb(77, 77, 77)',
  'gray31': 'rgb(79, 79, 79)',
  'gray32': 'rgb(82, 82, 82)',
  'gray33': 'rgb(84, 84, 84)',
  'gray34': 'rgb(87, 87, 87)',
  'gray35': 'rgb(89, 89, 89)',
  'gray36': 'rgb(92, 92, 92)',
  'gray37': 'rgb(94, 94, 94)',
  'gray38': 'rgb(97, 97, 97)',
  'gray39': 'rgb(99, 99, 99)',
  'gray4': 'rgb(10, 10, 10)',
  'gray40': 'rgb(102, 102, 102)',
  'gray41': 'rgb(105, 105, 105)',
  'gray42': 'rgb(107, 107, 107)',
  'gray43': 'rgb(110, 110, 110)',
  'gray44': 'rgb(112, 112, 112)',
  'gray45': 'rgb(115, 115, 115)',
  'gray46': 'rgb(117, 117, 117)',
  'gray47': 'rgb(120, 120, 120)',
  'gray48': 'rgb(122, 122, 122)',
  'gray49': 'rgb(125, 125, 125)',
  'gray5': 'rgb(13, 13, 13)',
  'gray50': 'rgb(127, 127, 127)',
  'gray51': 'rgb(130, 130, 130)',
  'gray52': 'rgb(133, 133, 133)',
  'gray53': 'rgb(135, 135, 135)',
  'gray54': 'rgb(138, 138, 138)',
  'gray55': 'rgb(140, 140, 140)',
  'gray56': 'rgb(143, 143, 143)',
  'gray57': 'rgb(145, 145, 145)',
  'gray58': 'rgb(148, 148, 148)',
  'gray59': 'rgb(150, 150, 150)',
  'gray6': 'rgb(15, 15, 15)',
  'gray60': 'rgb(153, 153, 153)',
  'gray61': 'rgb(156, 156, 156)',
  'gray62': 'rgb(158, 158, 158)',
  'gray63': 'rgb(161, 161, 161)',
  'gray64': 'rgb(163, 163, 163)',
  'gray65': 'rgb(166, 166, 166)',
  'gray66': 'rgb(168, 168, 168)',
  'gray67': 'rgb(171, 171, 171)',
  'gray68': 'rgb(173, 173, 173)',
  'gray69': 'rgb(176, 176, 176)',
  'gray7': 'rgb(18, 18, 18)',
  'gray70': 'rgb(179, 179, 179)',
  'gray71': 'rgb(181, 181, 181)',
  'gray72': 'rgb(184, 184, 184)',
  'gray73': 'rgb(186, 186, 186)',
  'gray74': 'rgb(189, 189, 189)',
  'gray75': 'rgb(191, 191, 191)',
  'gray76': 'rgb(194, 194, 194)',
  'gray77': 'rgb(196, 196, 196)',
  'gray78': 'rgb(199, 199, 199)',
  'gray79': 'rgb(201, 201, 201)',
  'gray8': 'rgb(20, 20, 20)',
  'gray80': 'rgb(204, 204, 204)',
  'gray81': 'rgb(207, 207, 207)',
  'gray82': 'rgb(209, 209, 209)',
  'gray83': 'rgb(212, 212, 212)',
  'gray84': 'rgb(214, 214, 214)',
  'gray85': 'rgb(217, 217, 217)',
  'gray86': 'rgb(219, 219, 219)',
  'gray87': 'rgb(222, 222, 222)',
  'gray88': 'rgb(224, 224, 224)',
  'gray89': 'rgb(227, 227, 227)',
  'gray9': 'rgb(23, 23, 23)',
  'gray90': 'rgb(229, 229, 229)',
  'gray91': 'rgb(232, 232, 232)',
  'gray92': 'rgb(235, 235, 235)',
  'gray93': 'rgb(237, 237, 237)',
  'gray94': 'rgb(240, 240, 240)',
  'gray95': 'rgb(242, 242, 242)',
  'gray96': 'rgb(245, 245, 245)',
  'gray97': 'rgb(247, 247, 247)',
  'gray98': 'rgb(250, 250, 250)',
  'gray99': 'rgb(252, 252, 252)',
  'green': 'rgb(0, 255, 0)',
  'green1': 'rgb(0, 255, 0)',
  'green2': 'rgb(0, 238, 0)',
  'green3': 'rgb(0, 205, 0)',
  'green4': 'rgb(0, 139, 0)',
  'greenyellow': 'rgb(173, 255, 47)',
  'grey': 'rgb(190, 190, 190)',
  'grey0': 'rgb(0, 0, 0)',
  'grey1': 'rgb(3, 3, 3)',
  'grey10': 'rgb(26, 26, 26)',
  'grey100': 'rgb(255, 255, 255)',
  'grey11': 'rgb(28, 28, 28)',
  'grey12': 'rgb(31, 31, 31)',
  'grey13': 'rgb(33, 33, 33)',
  'grey14': 'rgb(36, 36, 36)',
  'grey15': 'rgb(38, 38, 38)',
  'grey16': 'rgb(41, 41, 41)',
  'grey17': 'rgb(43, 43, 43)',
  'grey18': 'rgb(46, 46, 46)',
  'grey19': 'rgb(48, 48, 48)',
  'grey2': 'rgb(5, 5, 5)',
  'grey20': 'rgb(51, 51, 51)',
  'grey21': 'rgb(54, 54, 54)',
  'grey22': 'rgb(56, 56, 56)',
  'grey23': 'rgb(59, 59, 59)',
  'grey24': 'rgb(61, 61, 61)',
  'grey25': 'rgb(64, 64, 64)',
  'grey26': 'rgb(66, 66, 66)',
  'grey27': 'rgb(69, 69, 69)',
  'grey28': 'rgb(71, 71, 71)',
  'grey29': 'rgb(74, 74, 74)',
  'grey3': 'rgb(8, 8, 8)',
  'grey30': 'rgb(77, 77, 77)',
  'grey31': 'rgb(79, 79, 79)',
  'grey32': 'rgb(82, 82, 82)',
  'grey33': 'rgb(84, 84, 84)',
  'grey34': 'rgb(87, 87, 87)',
  'grey35': 'rgb(89, 89, 89)',
  'grey36': 'rgb(92, 92, 92)',
  'grey37': 'rgb(94, 94, 94)',
  'grey38': 'rgb(97, 97, 97)',
  'grey39': 'rgb(99, 99, 99)',
  'grey4': 'rgb(10, 10, 10)',
  'grey40': 'rgb(102, 102, 102)',
  'grey41': 'rgb(105, 105, 105)',
  'grey42': 'rgb(107, 107, 107)',
  'grey43': 'rgb(110, 110, 110)',
  'grey44': 'rgb(112, 112, 112)',
  'grey45': 'rgb(115, 115, 115)',
  'grey46': 'rgb(117, 117, 117)',
  'grey47': 'rgb(120, 120, 120)',
  'grey48': 'rgb(122, 122, 122)',
  'grey49': 'rgb(125, 125, 125)',
  'grey5': 'rgb(13, 13, 13)',
  'grey50': 'rgb(127, 127, 127)',
  'grey51': 'rgb(130, 130, 130)',
  'grey52': 'rgb(133, 133, 133)',
  'grey53': 'rgb(135, 135, 135)',
  'grey54': 'rgb(138, 138, 138)',
  'grey55': 'rgb(140, 140, 140)',
  'grey56': 'rgb(143, 143, 143)',
  'grey57': 'rgb(145, 145, 145)',
  'grey58': 'rgb(148, 148, 148)',
  'grey59': 'rgb(150, 150, 150)',
  'grey6': 'rgb(15, 15, 15)',
  'grey60': 'rgb(153, 153, 153)',
  'grey61': 'rgb(156, 156, 156)',
  'grey62': 'rgb(158, 158, 158)',
  'grey63': 'rgb(161, 161, 161)',
  'grey64': 'rgb(163, 163, 163)',
  'grey65': 'rgb(166, 166, 166)',
  'grey66': 'rgb(168, 168, 168)',
  'grey67': 'rgb(171, 171, 171)',
  'grey68': 'rgb(173, 173, 173)',
  'grey69': 'rgb(176, 176, 176)',
  'grey7': 'rgb(18, 18, 18)',
  'grey70': 'rgb(179, 179, 179)',
  'grey71': 'rgb(181, 181, 181)',
  'grey72': 'rgb(184, 184, 184)',
  'grey73': 'rgb(186, 186, 186)',
  'grey74': 'rgb(189, 189, 189)',
  'grey75': 'rgb(191, 191, 191)',
  'grey76': 'rgb(194, 194, 194)',
  'grey77': 'rgb(196, 196, 196)',
  'grey78': 'rgb(199, 199, 199)',
  'grey79': 'rgb(201, 201, 201)',
  'grey8': 'rgb(20, 20, 20)',
  'grey80': 'rgb(204, 204, 204)',
  'grey81': 'rgb(207, 207, 207)',
  'grey82': 'rgb(209, 209, 209)',
  'grey83': 'rgb(212, 212, 212)',
  'grey84': 'rgb(214, 214, 214)',
  'grey85': 'rgb(217, 217, 217)',
  'grey86': 'rgb(219, 219, 219)',
  'grey87': 'rgb(222, 222, 222)',
  'grey88': 'rgb(224, 224, 224)',
  'grey89': 'rgb(227, 227, 227)',
  'grey9': 'rgb(23, 23, 23)',
  'grey90': 'rgb(229, 229, 229)',
  'grey91': 'rgb(232, 232, 232)',
  'grey92': 'rgb(235, 235, 235)',
  'grey93': 'rgb(237, 237, 237)',
  'grey94': 'rgb(240, 240, 240)',
  'grey95': 'rgb(242, 242, 242)',
  'grey96': 'rgb(245, 245, 245)',
  'grey97': 'rgb(247, 247, 247)',
  'grey98': 'rgb(250, 250, 250)',
  'grey99': 'rgb(252, 252, 252)',
  'honeydew': 'rgb(240, 255, 240)',
  'honeydew1': 'rgb(240, 255, 240)',
  'honeydew2': 'rgb(224, 238, 224)',
  'honeydew3': 'rgb(193, 205, 193)',
  'honeydew4': 'rgb(131, 139, 131)',
  'hotpink': 'rgb(255, 105, 180)',
  'hotpink1': 'rgb(255, 110, 180)',
  'hotpink2': 'rgb(238, 106, 167)',
  'hotpink3': 'rgb(205, 96, 144)',
  'hotpink4': 'rgb(139, 58, 98)',
  'indianred': 'rgb(205, 92, 92)',
  'indianred1': 'rgb(255, 106, 106)',
  'indianred2': 'rgb(238, 99, 99)',
  'indianred3': 'rgb(205, 85, 85)',
  'indianred4': 'rgb(139, 58, 58)',
  'ivory': 'rgb(255, 255, 240)',
  'ivory1': 'rgb(255, 255, 240)',
  'ivory2': 'rgb(238, 238, 224)',
  'ivory3': 'rgb(205, 205, 193)',
  'ivory4': 'rgb(139, 139, 131)',
  'khaki': 'rgb(240, 230, 140)',
  'khaki1': 'rgb(255, 246, 143)',
  'khaki2': 'rgb(238, 230, 133)',
  'khaki3': 'rgb(205, 198, 115)',
  'khaki4': 'rgb(139, 134, 78)',
  'lavender': 'rgb(230, 230, 250)',
  'lavenderblush': 'rgb(255, 240, 245)',
  'lavenderblush1': 'rgb(255, 240, 245)',
  'lavenderblush2': 'rgb(238, 224, 229)',
  'lavenderblush3': 'rgb(205, 193, 197)',
  'lavenderblush4': 'rgb(139, 131, 134)',
  'lawngreen': 'rgb(124, 252, 0)',
  'lemonchiffon': 'rgb(255, 250, 205)',
  'lemonchiffon1': 'rgb(255, 250, 205)',
  'lemonchiffon2': 'rgb(238, 233, 191)',
  'lemonchiffon3': 'rgb(205, 201, 165)',
  'lemonchiffon4': 'rgb(139, 137, 112)',
  'lightblue': 'rgb(173, 216, 230)',
  'lightblue1': 'rgb(191, 239, 255)',
  'lightblue2': 'rgb(178, 223, 238)',
  'lightblue3': 'rgb(154, 192, 205)',
  'lightblue4': 'rgb(104, 131, 139)',
  'lightcoral': 'rgb(240, 128, 128)',
  'lightcyan': 'rgb(224, 255, 255)',
  'lightcyan1': 'rgb(224, 255, 255)',
  'lightcyan2': 'rgb(209, 238, 238)',
  'lightcyan3': 'rgb(180, 205, 205)',
  'lightcyan4': 'rgb(122, 139, 139)',
  'lightgoldenrod': 'rgb(238, 221, 130)',
  'lightgoldenrod1': 'rgb(255, 236, 139)',
  'lightgoldenrod2': 'rgb(238, 220, 130)',
  'lightgoldenrod3': 'rgb(205, 190, 112)',
  'lightgoldenrod4': 'rgb(139, 129, 76)',
  'lightgoldenrodyellow': 'rgb(250, 250, 210)',
  'lightgray': 'rgb(211, 211, 211)',
  'lightgreen': 'rgb(144, 238, 144)',
  'lightgrey': 'rgb(211, 211, 211)',
  'lightpink': 'rgb(255, 182, 193)',
  'lightpink1': 'rgb(255, 174, 185)',
  'lightpink2': 'rgb(238, 162, 173)',
  'lightpink3': 'rgb(205, 140, 149)',
  'lightpink4': 'rgb(139, 95, 101)',
  'lightsalmon': 'rgb(255, 160, 122)',
  'lightsalmon1': 'rgb(255, 160, 122)',
  'lightsalmon2': 'rgb(238, 149, 114)',
  'lightsalmon3': 'rgb(205, 129, 98)',
  'lightsalmon4': 'rgb(139, 87, 66)',
  'lightseagreen': 'rgb(32, 178, 170)',
  'lightskyblue': 'rgb(135, 206, 250)',
  'lightskyblue1': 'rgb(176, 226, 255)',
  'lightskyblue2': 'rgb(164, 211, 238)',
  'lightskyblue3': 'rgb(141, 182, 205)',
  'lightskyblue4': 'rgb(96, 123, 139)',
  'lightslateblue': 'rgb(132, 112, 255)',
  'lightslategray': 'rgb(119, 136, 153)',
  'lightslategrey': 'rgb(119, 136, 153)',
  'lightsteelblue': 'rgb(176, 196, 222)',
  'lightsteelblue1': 'rgb(202, 225, 255)',
  'lightsteelblue2': 'rgb(188, 210, 238)',
  'lightsteelblue3': 'rgb(162, 181, 205)',
  'lightsteelblue4': 'rgb(110, 123, 139)',
  'lightyellow': 'rgb(255, 255, 224)',
  'lightyellow1': 'rgb(255, 255, 224)',
  'lightyellow2': 'rgb(238, 238, 209)',
  'lightyellow3': 'rgb(205, 205, 180)',
  'lightyellow4': 'rgb(139, 139, 122)',
  'limegreen': 'rgb(50, 205, 50)',
  'linen': 'rgb(250, 240, 230)',
  'magenta': 'rgb(255, 0, 255)',
  'magenta1': 'rgb(255, 0, 255)',
  'magenta2': 'rgb(238, 0, 238)',
  'magenta3': 'rgb(205, 0, 205)',
  'magenta4': 'rgb(139, 0, 139)',
  'maroon': 'rgb(176, 48, 96)',
  'maroon1': 'rgb(255, 52, 179)',
  'maroon2': 'rgb(238, 48, 167)',
  'maroon3': 'rgb(205, 41, 144)',
  'maroon4': 'rgb(139, 28, 98)',
  'mediumaquamarine': 'rgb(102, 205, 170)',
  'mediumblue': 'rgb(0, 0, 205)',
  'mediumorchid': 'rgb(186, 85, 211)',
  'mediumorchid1': 'rgb(224, 102, 255)',
  'mediumorchid2': 'rgb(209, 95, 238)',
  'mediumorchid3': 'rgb(180, 82, 205)',
  'mediumorchid4': 'rgb(122, 55, 139)',
  'mediumpurple': 'rgb(147, 112, 219)',
  'mediumpurple1': 'rgb(171, 130, 255)',
  'mediumpurple2': 'rgb(159, 121, 238)',
  'mediumpurple3': 'rgb(137, 104, 205)',
  'mediumpurple4': 'rgb(93, 71, 139)',
  'mediumseagreen': 'rgb(60, 179, 113)',
  'mediumslateblue': 'rgb(123, 104, 238)',
  'mediumspringgreen': 'rgb(0, 250, 154)',
  'mediumturquoise': 'rgb(72, 209, 204)',
  'mediumvioletred': 'rgb(199, 21, 133)',
  'midnightblue': 'rgb(25, 25, 112)',
  'mintcream': 'rgb(245, 255, 250)',
  'mistyrose': 'rgb(255, 228, 225)',
  'mistyrose1': 'rgb(255, 228, 225)',
  'mistyrose2': 'rgb(238, 213, 210)',
  'mistyrose3': 'rgb(205, 183, 181)',
  'mistyrose4': 'rgb(139, 125, 123)',
  'moccasin': 'rgb(255, 228, 181)',
  'navajowhite': 'rgb(255, 222, 173)',
  'navajowhite1': 'rgb(255, 222, 173)',
  'navajowhite2': 'rgb(238, 207, 161)',
  'navajowhite3': 'rgb(205, 179, 139)',
  'navajowhite4': 'rgb(139, 121, 94)',
  'navy': 'rgb(0, 0, 128)',
  'navyblue': 'rgb(0, 0, 128)',
  'oldlace': 'rgb(253, 245, 230)',
  'olivedrab': 'rgb(107, 142, 35)',
  'olivedrab1': 'rgb(192, 255, 62)',
  'olivedrab2': 'rgb(179, 238, 58)',
  'olivedrab3': 'rgb(154, 205, 50)',
  'olivedrab4': 'rgb(105, 139, 34)',
  'orange': 'rgb(255, 165, 0)',
  'orange1': 'rgb(255, 165, 0)',
  'orange2': 'rgb(238, 154, 0)',
  'orange3': 'rgb(205, 133, 0)',
  'orange4': 'rgb(139, 90, 0)',
  'orangered': 'rgb(255, 69, 0)',
  'orangered1': 'rgb(255, 69, 0)',
  'orangered2': 'rgb(238, 64, 0)',
  'orangered3': 'rgb(205, 55, 0)',
  'orangered4': 'rgb(139, 37, 0)',
  'orchid': 'rgb(218, 112, 214)',
  'orchid1': 'rgb(255, 131, 250)',
  'orchid2': 'rgb(238, 122, 233)',
  'orchid3': 'rgb(205, 105, 201)',
  'orchid4': 'rgb(139, 71, 137)',
  'palegoldenrod': 'rgb(238, 232, 170)',
  'palegreen': 'rgb(152, 251, 152)',
  'palegreen1': 'rgb(154, 255, 154)',
  'palegreen2': 'rgb(144, 238, 144)',
  'palegreen3': 'rgb(124, 205, 124)',
  'palegreen4': 'rgb(84, 139, 84)',
  'paleturquoise': 'rgb(175, 238, 238)',
  'paleturquoise1': 'rgb(187, 255, 255)',
  'paleturquoise2': 'rgb(174, 238, 238)',
  'paleturquoise3': 'rgb(150, 205, 205)',
  'paleturquoise4': 'rgb(102, 139, 139)',
  'palevioletred': 'rgb(219, 112, 147)',
  'palevioletred1': 'rgb(255, 130, 171)',
  'palevioletred2': 'rgb(238, 121, 159)',
  'palevioletred3': 'rgb(205, 104, 137)',
  'palevioletred4': 'rgb(139, 71, 93)',
  'papayawhip': 'rgb(255, 239, 213)',
  'peachpuff': 'rgb(255, 218, 185)',
  'peachpuff1': 'rgb(255, 218, 185)',
  'peachpuff2': 'rgb(238, 203, 173)',
  'peachpuff3': 'rgb(205, 175, 149)',
  'peachpuff4': 'rgb(139, 119, 101)',
  'peru': 'rgb(205, 133, 63)',
  'pink': 'rgb(255, 192, 203)',
  'pink1': 'rgb(255, 181, 197)',
  'pink2': 'rgb(238, 169, 184)',
  'pink3': 'rgb(205, 145, 158)',
  'pink4': 'rgb(139, 99, 108)',
  'plum': 'rgb(221, 160, 221)',
  'plum1': 'rgb(255, 187, 255)',
  'plum2': 'rgb(238, 174, 238)',
  'plum3': 'rgb(205, 150, 205)',
  'plum4': 'rgb(139, 102, 139)',
  'powderblue': 'rgb(176, 224, 230)',
  'purple': 'rgb(160, 32, 240)',
  'purple1': 'rgb(155, 48, 255)',
  'purple2': 'rgb(145, 44, 238)',
  'purple3': 'rgb(125, 38, 205)',
  'purple4': 'rgb(85, 26, 139)',
  'red': 'rgb(255, 0, 0)',
  'red1': 'rgb(255, 0, 0)',
  'red2': 'rgb(238, 0, 0)',
  'red3': 'rgb(205, 0, 0)',
  'red4': 'rgb(139, 0, 0)',
  'rosybrown': 'rgb(188, 143, 143)',
  'rosybrown1': 'rgb(255, 193, 193)',
  'rosybrown2': 'rgb(238, 180, 180)',
  'rosybrown3': 'rgb(205, 155, 155)',
  'rosybrown4': 'rgb(139, 105, 105)',
  'royalblue': 'rgb(65, 105, 225)',
  'royalblue1': 'rgb(72, 118, 255)',
  'royalblue2': 'rgb(67, 110, 238)',
  'royalblue3': 'rgb(58, 95, 205)',
  'royalblue4': 'rgb(39, 64, 139)',
  'saddlebrown': 'rgb(139, 69, 19)',
  'salmon': 'rgb(250, 128, 114)',
  'salmon1': 'rgb(255, 140, 105)',
  'salmon2': 'rgb(238, 130, 98)',
  'salmon3': 'rgb(205, 112, 84)',
  'salmon4': 'rgb(139, 76, 57)',
  'sandybrown': 'rgb(244, 164, 96)',
  'seagreen': 'rgb(46, 139, 87)',
  'seagreen1': 'rgb(84, 255, 159)',
  'seagreen2': 'rgb(78, 238, 148)',
  'seagreen3': 'rgb(67, 205, 128)',
  'seagreen4': 'rgb(46, 139, 87)',
  'seashell': 'rgb(255, 245, 238)',
  'seashell1': 'rgb(255, 245, 238)',
  'seashell2': 'rgb(238, 229, 222)',
  'seashell3': 'rgb(205, 197, 191)',
  'seashell4': 'rgb(139, 134, 130)',
  'sienna': 'rgb(160, 82, 45)',
  'sienna1': 'rgb(255, 130, 71)',
  'sienna2': 'rgb(238, 121, 66)',
  'sienna3': 'rgb(205, 104, 57)',
  'sienna4': 'rgb(139, 71, 38)',
  'skyblue': 'rgb(135, 206, 235)',
  'skyblue1': 'rgb(135, 206, 255)',
  'skyblue2': 'rgb(126, 192, 238)',
  'skyblue3': 'rgb(108, 166, 205)',
  'skyblue4': 'rgb(74, 112, 139)',
  'slateblue': 'rgb(106, 90, 205)',
  'slateblue1': 'rgb(131, 111, 255)',
  'slateblue2': 'rgb(122, 103, 238)',
  'slateblue3': 'rgb(105, 89, 205)',
  'slateblue4': 'rgb(71, 60, 139)',
  'slategray': 'rgb(112, 128, 144)',
  'slategray1': 'rgb(198, 226, 255)',
  'slategray2': 'rgb(185, 211, 238)',
  'slategray3': 'rgb(159, 182, 205)',
  'slategray4': 'rgb(108, 123, 139)',
  'slategrey': 'rgb(112, 128, 144)',
  'snow': 'rgb(255, 250, 250)',
  'snow1': 'rgb(255, 250, 250)',
  'snow2': 'rgb(238, 233, 233)',
  'snow3': 'rgb(205, 201, 201)',
  'snow4': 'rgb(139, 137, 137)',
  'springgreen': 'rgb(0, 255, 127)',
  'springgreen1': 'rgb(0, 255, 127)',
  'springgreen2': 'rgb(0, 238, 118)',
  'springgreen3': 'rgb(0, 205, 102)',
  'springgreen4': 'rgb(0, 139, 69)',
  'steelblue': 'rgb(70, 130, 180)',
  'steelblue1': 'rgb(99, 184, 255)',
  'steelblue2': 'rgb(92, 172, 238)',
  'steelblue3': 'rgb(79, 148, 205)',
  'steelblue4': 'rgb(54, 100, 139)',
  'tan': 'rgb(210, 180, 140)',
  'tan1': 'rgb(255, 165, 79)',
  'tan2': 'rgb(238, 154, 73)',
  'tan3': 'rgb(205, 133, 63)',
  'tan4': 'rgb(139, 90, 43)',
  'thistle': 'rgb(216, 191, 216)',
  'thistle1': 'rgb(255, 225, 255)',
  'thistle2': 'rgb(238, 210, 238)',
  'thistle3': 'rgb(205, 181, 205)',
  'thistle4': 'rgb(139, 123, 139)',
  'tomato': 'rgb(255, 99, 71)',
  'tomato1': 'rgb(255, 99, 71)',
  'tomato2': 'rgb(238, 92, 66)',
  'tomato3': 'rgb(205, 79, 57)',
  'tomato4': 'rgb(139, 54, 38)',
  'turquoise': 'rgb(64, 224, 208)',
  'turquoise1': 'rgb(0, 245, 255)',
  'turquoise2': 'rgb(0, 229, 238)',
  'turquoise3': 'rgb(0, 197, 205)',
  'turquoise4': 'rgb(0, 134, 139)',
  'violet': 'rgb(238, 130, 238)',
  'violetred': 'rgb(208, 32, 144)',
  'violetred1': 'rgb(255, 62, 150)',
  'violetred2': 'rgb(238, 58, 140)',
  'violetred3': 'rgb(205, 50, 120)',
  'violetred4': 'rgb(139, 34, 82)',
  'wheat': 'rgb(245, 222, 179)',
  'wheat1': 'rgb(255, 231, 186)',
  'wheat2': 'rgb(238, 216, 174)',
  'wheat3': 'rgb(205, 186, 150)',
  'wheat4': 'rgb(139, 126, 102)',
  'white': 'rgb(255, 255, 255)',
  'whitesmoke': 'rgb(245, 245, 245)',
  'yellow': 'rgb(255, 255, 0)',
  'yellow1': 'rgb(255, 255, 0)',
  'yellow2': 'rgb(238, 238, 0)',
  'yellow3': 'rgb(205, 205, 0)',
  'yellow4': 'rgb(139, 139, 0)',
  'yellowgreen': 'rgb(154, 205, 50)',
};
// SOURCE FILE: libdot/js/lib_event.js
// Copyright 2013 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * An event is a JavaScript function with addListener and removeListener
 * properties.
 *
 * When the endpoint function is called, all of the listeners will be invoked
 * in the order they were attached.
 *
 * The returned function will have the list of callbacks as its 'observers'
 * property.
 *
 * @return {function(...*)} A function that, when called, invokes all callbacks
 *     with whatever arguments it was passed.
 */
lib.Event = function() {
  const ep = function(...args) {
    ep.observers.forEach((callback) => callback.apply(null, args));
  };

  /**
   * Add a callback function.
   *
   * @param {function(...*)} callback The function to call back.
   */
  ep.addListener = function(callback) {
    ep.observers.push(callback);
  };

  /**
   * Remove a callback function.
   *
   * If the function is registered more than once (weird), all will be removed.
   *
   * @param {function(...*)} callback The function to remove.
   */
  ep.removeListener = function(callback) {
    ep.observers = ep.observers.filter((cb) => cb !== callback);
  };

  ep.observers = [];

  return ep;
};
// SOURCE FILE: libdot/js/lib_f.js
// Copyright 2012 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Grab bag of utility functions.
 */
lib.f = {};

/**
 * Replace variable references in a string.
 *
 * Variables are of the form %FUNCTION(VARNAME).  FUNCTION is an optional
 * escape function to apply to the value.
 *
 * For example
 *   lib.f.replaceVars("%(greeting), %encodeURIComponent(name)",
 *                     { greeting: "Hello",
 *                       name: "Google+" });
 *
 * Will result in "Hello, Google%2B".
 *
 * @param {string} str String containing variable references.
 * @param {!Object<string, string>} vars Variables to substitute in.
 * @return {string} String with references substituted.
 */
lib.f.replaceVars = function(str, vars) {
  return str.replace(/%([a-z]*)\(([^)]+)\)/gi, function(match, fn, varname) {
      if (typeof vars[varname] == 'undefined') {
        throw new Error(`Unknown variable: ${varname}`);
      }

      let rv = vars[varname];

      if (fn in lib.f.replaceVars.functions) {
        rv = lib.f.replaceVars.functions[fn](rv);
      } else if (fn) {
        throw new Error(`Unknown escape function: ${fn}`);
      }

      return rv;
    });
};

/**
 * Functions that can be used with replaceVars.
 *
 * Clients can add to this list to extend lib.f.replaceVars().
 */
lib.f.replaceVars.functions = {
  encodeURI: encodeURI,
  encodeURIComponent: encodeURIComponent,
  escapeHTML: function(str) {
    const map = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '"': '&quot;',
      "'": '&#39;',
    };

    return str.replace(/[<>&"']/g, (m) => map[m]);
  },
};

/**
 * Convert a relative path to a fully qualified URI.
 *
 * @param {string} path Relative path
 * @return {string} Fully qualified URI.
 */
lib.f.getURL = function(path) {
  if (lib.f.getURL.chromeSupported()) {
    return chrome.runtime.getURL(path);
  }

  // Use current location origin if path is absolute.
  if (path.startsWith('/')) {
    return globalThis.location.origin + path;
  }

  return path;
};

/**
 * Determine whether the runtime is Chrome (or equiv).
 *
 * @return {boolean} True if chrome.runtime.getURL is supported.
 */
lib.f.getURL.chromeSupported = function() {
  return !!(globalThis.chrome?.runtime?.getURL);
};

/**
 * Clamp a given integer to a specified range.
 *
 * @param {number} v The value to be clamped.
 * @param {number} min The minimum acceptable value.
 * @param {number} max The maximum acceptable value.
 * @return {number} The clamped value.
 */
lib.f.clamp = function(v, min, max) {
  if (v < min) {
    return min;
  }
  if (v > max) {
    return max;
  }
  return v;
};

/**
 * Left pad a number to a given length with leading zeros.
 *
 * @param {string|number} number The number to pad.
 * @param {number} length The desired length.
 * @return {string} The padded number as a string.
 */
lib.f.zpad = function(number, length) {
  return String(number).padStart(length, '0');
};

/**
 * Return the current call stack after skipping a given number of frames.
 *
 * This method is intended to be used for debugging only.  It returns an
 * Object instead of an Array, because the console stringifies arrays by
 * default and that's not what we want.
 *
 * A typical call might look like...
 *
 *    console.log('Something wicked this way came', lib.f.getStack());
 *    //                         Notice the comma ^
 *
 * This would print the message to the js console, followed by an object
 * which can be clicked to reveal the stack.
 *
 * @param {number=} ignoreFrames How many inner stack frames to ignore.  The
 *     innermost 'getStack' call is always ignored.
 * @param {number=} count How many frames to return.
 * @return {!Array<string>} The stack frames.
 */
lib.f.getStack = function(ignoreFrames = 0, count = undefined) {
  const stackArray = (new Error()).stack.split('\n');

  // Always ignore the Error() object and getStack call itself.
  // [0] = 'Error'
  // [1] = '    at Object.lib.f.getStack (file:///.../lib_f.js:267:23)'
  ignoreFrames += 2;

  const max = stackArray.length - ignoreFrames;
  if (count === undefined) {
    count = max;
  } else {
    count = lib.f.clamp(count, 0, max);
  }

  // Remove the leading spaces and "at" from each line:
  // '    at window.onload (file:///.../lib_test.js:11:18)'
  const stackObject = new Array();
  for (let i = ignoreFrames; i < count + ignoreFrames; ++i) {
    stackObject.push(stackArray[i].replace(/^\s*at\s+/, ''));
  }

  return stackObject;
};

/**
 * Divides the two numbers and floors the results, unless the remainder is less
 * than an incredibly small value, in which case it returns the ceiling.
 * This is useful when the number are truncated approximations of longer
 * values, and so doing division with these numbers yields a result incredibly
 * close to a whole number.
 *
 * @param {number} numerator
 * @param {number} denominator
 * @return {number}
 */
lib.f.smartFloorDivide = function(numerator, denominator) {
  const val = numerator / denominator;
  const ceiling = Math.ceil(val);
  if (ceiling - val < .0001) {
    return ceiling;
  } else {
    return Math.floor(val);
  }
};

/**
 * Get a random integer in a range (inclusive).
 *
 * @param {number} min The lowest integer in the range.
 * @param {number} max The highest integer in the range.
 * @return {number} A random number between min & max.
 */
lib.f.randomInt = function(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

/**
 * Get the current OS.
 *
 * @return {!Promise<string>} A promise that resolves to a constant in
 *     runtime.PlatformOs.
 */
lib.f.getOs = function() {
  // Try the brower extensions API.
  if (globalThis.browser?.runtime?.getPlatformInfo) {
    return browser.runtime.getPlatformInfo().then((info) => info.os);
  }

  // Use the native Chrome API if available.
  if (globalThis.chrome?.runtime?.getPlatformInfo) {
    return new Promise((resolve, reject) => {
      return chrome.runtime.getPlatformInfo((info) => resolve(info.os));
    });
  }

  // Fallback logic.  Capture the major OS's.  The rest should support the
  // browser API above.
  if (globalThis.navigator?.userAgent) {
    const ua = navigator.userAgent;
    if (ua.includes('Mac OS X')) {
      return Promise.resolve('mac');
    } else if (ua.includes('CrOS')) {
      return Promise.resolve('cros');
    } else if (ua.includes('Linux')) {
      return Promise.resolve('linux');
    } else if (ua.includes('Android')) {
      return Promise.resolve('android');
    } else if (ua.includes('Windows')) {
      return Promise.resolve('windows');
    }
  }

  // Probe node environment.
  if (typeof process != 'undefined') {
    return Promise.resolve('node');
  }

  // Still here?  No idea.
  return Promise.reject(null);
};

/**
 * Get the current Chrome milestone version.
 *
 * @return {number} The milestone number if we're running on Chrome, else NaN.
 */
lib.f.getChromeMilestone = function() {
  if (globalThis.navigator?.userAgent) {
    const ary = navigator.userAgent.match(/\sChrome\/(\d+)/);
    if (ary) {
      return parseInt(ary[1], 10);
    }
  }

  // Returning NaN will make all number comparisons fail.
  return NaN;
};

/**
 * Return the lastError string in the browser.
 *
 * This object might live in different locations, and it isn't always defined
 * (if there hasn't been a "last error").  Wrap all that ugliness here.
 *
 * @param {?string=} defaultMsg The default message if no error is found.
 * @return {?string} The last error message from the browser.
 */
lib.f.lastError = function(defaultMsg = null) {
  let lastError;
  if (globalThis.browser?.runtime) {
    lastError = browser.runtime.lastError;
  } else if (globalThis.chrome?.runtime) {
    lastError = chrome.runtime.lastError;
  }

  if (lastError && lastError.message) {
    return lastError.message;
  } else {
    return defaultMsg;
  }
};

/**
 * Just like window.open, but enforce noopener.
 *
 * If we're not careful, the website we open will have access to use via its
 * window.opener field.  Newer browser support putting 'noopener' into the
 * features argument, but there are many which still don't.  So hack it.
 *
 * @param {string=} url The URL to point the new window to.
 * @param {string=} name The name of the new window.
 * @param {string=} features The window features to enable.
 * @return {?Window} The newly opened window.
 */
lib.f.openWindow = function(url, name = undefined, features = undefined) {
  // We create the window first without the URL loaded.
  const win = globalThis.open(undefined, name, features);

  // If the system is blocking window.open, don't crash.
  if (win !== null) {
    // Clear the opener setting before redirecting.
    win.opener = null;

    // Now it's safe to redirect.  Skip this step if the url is not set so we
    // mimic the window.open behavior more precisely.
    if (url) {
      win.location = url;
    }
  }

  return win;
};
// SOURCE FILE: libdot/js/lib_i18n.js
// Copyright 2018 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Wrappers over the browser i18n helpers.
 *
 * Arguably some of these functions should be l10n, but oh well.
 */
lib.i18n = {};

/**
 * Convenience shortcut to the browser i18n object.
 */
lib.i18n.browser_ =
    globalThis.browser?.i18n ? browser.i18n :
    globalThis.chrome?.i18n ? chrome.i18n :
    null;

/**
 * Return whether the browser supports i18n natively.
 *
 * @return {boolean} True if browser.i18n or chrome.i18n exists.
 */
lib.i18n.browserSupported = function() {
  return lib.i18n.browser_ !== null;
};

/**
 * Get the list of accepted UI languages.
 *
 * https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/i18n/getAcceptLanguages
 *
 * @return {!Promise<!Array<string>>} Promise resolving to the list of locale
 *     names.
 */
lib.i18n.getAcceptLanguages = function() {
  if (lib.i18n.browser_) {
    return new Promise((resolve) => {
      lib.i18n.browser_.getAcceptLanguages((languages) => {
        // Chrome might be in a bad state and not return any languages.  If we
        // pass this up to the caller who isn't expecting undefined, they'll
        // probably crash.  Fallback to the default language that we expect all
        // translations to have.
        if (!languages) {
          // Clear the error to avoid throwing an unchecked error.
          console.error('getAcceptLanguages failed', lib.f.lastError());
          languages = ['en'];
        }

        resolve(languages);
      });
    });
  } else {
    const languages = navigator.languages || [navigator.language];
    return Promise.resolve(languages);
  }
};

/**
 * Get a message by name, optionally replacing arguments too.
 *
 * https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/i18n/getMessage
 *
 * @param {string} msgname The id for this localized string.
 * @param {?Array<string>=} substitutions Any replacements in the string.
 * @param {string=} fallback Translation if the message wasn't found.
 * @return {string} The translated message.
 */
lib.i18n.getMessage = function(msgname, substitutions = [], fallback = '') {
  // First let the native browser APIs handle everything for us.
  if (lib.i18n.browser_) {
    const message = lib.i18n.browser_.getMessage(msgname, substitutions);
    if (message) {
      return message;
    }
  }

  // Do our best to get something reasonable.
  return lib.i18n.replaceReferences(fallback, substitutions);
};

/**
 * Replace $1...$n references with the elements of the args array.
 *
 * This largely behaves like Chrome's getMessage helper.  The $# references are
 * always replaced/removed regardless of the specified substitutions.
 *
 * @param {string} msg String containing the message and argument references.
 * @param {(?Array<string>|string)=} args Array containing the argument values,
 *     or single value.
 * @return {string} The message with replacements expanded.
 */
lib.i18n.replaceReferences = function(msg, args = []) {
  // The Chrome API allows a single substitution as a string rather than array.
  if (args === null) {
    args = [];
  }
  if (!(args instanceof Array)) {
    args = [args];
  }

  return msg.replace(/\$(\d+)/g, (m, index) => {
    return index <= args.length ? args[index - 1] : '';
  });
};

/**
 * This function aims to copy the chrome.i18n mapping from language to which
 * _locales/<locale>/messages.json translation is used.  E.g. en-AU maps to
 * en_GB.
 * https://cs.chromium.org/chromium/src/ui/base/l10n/l10n_util.cc?type=cs&q=CheckAndResolveLocale
 *
 * @param {string} language language from navigator.languages.
 * @return {!Array<string>} priority list of locales for translation.
 */
lib.i18n.resolveLanguage = function(language) {
  const [lang, region] = language.toLowerCase().split(/[-_]/, 2);

  // Map es-RR other than es-ES to es-419 (Chrome's Latin American
  // Spanish locale).
  if (lang == 'es') {
    if ([undefined, 'es'].includes(region)) {
      return ['es'];
    }
    return ['es_419'];
  }

  // Map pt-RR other than pt-BR to pt-PT. Note that "pt" by itself maps to
  // pt-BR (logic below).
  if (lang == 'pt') {
    if ([undefined, 'br'].includes(region)) {
      return ['pt_BR'];
    }
    return ['pt_PT'];
  }

  // Map zh-HK and zh-MO to zh-TW. Otherwise, zh-FOO is mapped to zh-CN.
  if (lang == 'zh') {
    if (['tw', 'hk', 'mo'].includes(region)) {
      return ['zh_TW'];
    }
    return ['zh_CN'];
  }

  // Map Liberian and Filipino English to US English, and everything else to
  // British English.
  if (lang == 'en') {
    if ([undefined, 'us', 'lr', 'ph'].includes(region)) {
      return ['en'];
    }

    // Our GB translation is not complete, so need to add 'en' as a fallback.
    return ['en_GB', 'en'];
  }

  if (region) {
    return [language.replace(/-/g, '_'), lang];
  } else {
    return [lang];
  }
};
// SOURCE FILE: libdot/js/lib_message_manager.js
// Copyright 2012 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * MessageManager class handles internationalized strings.
 *
 * Note: chrome.i18n isn't sufficient because...
 *     1. There's a bug in chrome that makes it unavailable in iframes:
 *        https://crbug.com/130200
 *     2. The client code may not be packaged in a Chrome extension.
 *     3. The client code may be part of a library packaged in a third-party
 *        Chrome extension.
 *
 * @param {!Array<string>} languages List of languages to load, in the order
 *     they are preferred.  The first language found will be used.  'en' is
 *     automatically added as the last language if it is not already present.
 * @param {boolean=} useCrlf If true, '\n' in messages are substituted for
 *     '\r\n'.  This fixes the translation process which discards '\r'
 *     characters.
 * @constructor
 */
lib.MessageManager = function(languages, useCrlf = false) {
  /**
   * @private {!Array<string>}
   * @const
   */
  this.languages_ = [];
  let stop = false;
  for (let i = 0; i < languages.length && !stop; i++) {
    for (const lang of lib.i18n.resolveLanguage(languages[i])) {
      // There is no point having any language with lower priorty than 'en'
      // since 'en' always contains all messages.
      if (lang == 'en') {
        stop = true;
        break;
      }
      if (!this.languages_.includes(lang)) {
        this.languages_.push(lang);
      }
    }
  }
  // Always have 'en' as last fallback.
  this.languages_.push('en');

  this.useCrlf = useCrlf;

  /**
   * @private {!Object<string, string>}
   * @const
   */
  this.messages_ = {};
};

/**
 * @typedef {!Object<string, {
 *     message: string,
 *     description: (string|undefined),
 *     placeholders: ({content: string, example: string}|undefined),
 * }>}
 */
lib.MessageManager.Messages;

/**
 * Add message definitions to the message manager.
 *
 * This takes an object of the same format of a Chrome messages.json file.  See
 * <https://developer.chrome.com/extensions/i18n-messages>.
 *
 * @param {!lib.MessageManager.Messages} defs The message to add to the
 *     database.
 */
lib.MessageManager.prototype.addMessages = function(defs) {
  for (const key in defs) {
    const def = defs[key];

    if (!def.placeholders) {
      // Upper case key into this.messages_ since our translated
      // bundles are lower case, but we request msg as upper.
      this.messages_[key.toUpperCase()] = def.message;
    } else {
      // Replace "$NAME$" placeholders with "$1", etc.
      this.messages_[key.toUpperCase()] =
          def.message.replace(/\$([a-z][^\s$]+)\$/ig, function(m, name) {
            return defs[key].placeholders[name.toUpperCase()].content;
          });
    }
  }
};

/**
 * Load language message bundles.  Loads in reverse order so that higher
 * priority languages overwrite lower priority.
 *
 * @param {string} pattern A url pattern containing a "$1" where the locale
 *     name should go.
 */
lib.MessageManager.prototype.findAndLoadMessages = async function(pattern) {
  if (lib.i18n.browserSupported()) {
    return;
  }

  for (let i = this.languages_.length - 1; i >= 0; i--) {
    const lang = this.languages_[i];
    const url = lib.i18n.replaceReferences(pattern, lang);
    try {
      await this.loadMessages(url);
    } catch (e) {
      console.warn(
          `Error fetching ${lang} messages at ${url}`, e,
          'Trying all languages in reverse order:', this.languages_);
    }
  }
};

/**
 * Load messages from a messages.json file.
 *
 * @param {string} url The URL to load the messages from.
 * @return {!Promise<void>}
 */
lib.MessageManager.prototype.loadMessages = function(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onload = () => {
      try {
        this.addMessages(/** @type {!lib.MessageManager.Messages} */ (
            JSON.parse(xhr.responseText)));
        resolve();
      } catch (e) {
        // Error parsing JSON.
        reject(e);
      }
    };
    xhr.onerror = () => reject(xhr);

    xhr.open('GET', url);
    xhr.send();
  });
};

/**
 * Get a message by name, optionally replacing arguments too.
 *
 * @param {string} msgname String containing the name of the message to get.
 * @param {!Array<string>=} args Optional array containing the argument values.
 * @param {string=} fallback Optional value to return if the msgname is not
 *     found.  Returns the message name by default.
 * @return {string} The formatted translation.
 */
lib.MessageManager.prototype.get = function(msgname, args, fallback) {
  // First try the integrated browser getMessage.  We prefer that over any
  // registered messages as only the browser supports translations.
  let message = lib.i18n.getMessage(msgname, args);
  if (!message) {
    // Look it up in the registered cache next.
    message = this.messages_[msgname];
    if (!message) {
      console.warn('Unknown message: ' + msgname);
      message = fallback === undefined ? msgname : fallback;
      // Register the message with the default to avoid multiple warnings.
      this.messages_[msgname] = message;
    }
    message = lib.i18n.replaceReferences(message, args);
  }
  if (this.useCrlf) {
    message = message.replace(/\n/g, '\r\n');
  }
  return message;
};

/**
 * Process all of the "i18n" html attributes found in a given element.
 *
 * The real work happens in processI18nAttribute.
 *
 * @param {!HTMLDocument|!Element} node The element whose nodes will be
 *     translated.
 */
lib.MessageManager.prototype.processI18nAttributes = function(node) {
  const nodes = node.querySelectorAll('[i18n]');

  for (let i = 0; i < nodes.length; i++) {
    this.processI18nAttribute(nodes[i]);
  }
};

/**
 * Process the "i18n" attribute in the specified node.
 *
 * The i18n attribute should contain a JSON object.  The keys are taken to
 * be attribute names, and the values are message names.
 *
 * If the JSON object has a "_" (underscore) key, its value is used as the
 * textContent of the element.
 *
 * Message names can refer to other attributes on the same element with by
 * prefixing with a dollar sign.  For example...
 *
 *   <button id='send-button'
 *           i18n='{"aria-label": "$id", "_": "SEND_BUTTON_LABEL"}'
 *           ></button>
 *
 * The aria-label message name will be computed as "SEND_BUTTON_ARIA_LABEL".
 * Notice that the "id" attribute was appended to the target attribute, and
 * the result converted to UPPER_AND_UNDER style.
 *
 * @param {!Element} node The element to translate.
 */
lib.MessageManager.prototype.processI18nAttribute = function(node) {
  // Convert the "lower-and-dashes" attribute names into
  // "UPPER_AND_UNDER" style.
  const thunk = (str) => str.replace(/-/g, '_').toUpperCase();

  let i18n = node.getAttribute('i18n');
  if (!i18n) {
    return;
  }

  try {
    i18n = JSON.parse(i18n);
  } catch (ex) {
    console.error('Can\'t parse ' + node.tagName + '#' + node.id + ': ' + i18n);
    throw ex;
  }

  // Load all the messages specified in the i18n attributes.
  for (let key in i18n) {
    // The node attribute we'll be setting.
    const attr = key;

    let msgname = i18n[key];
    // For "=foo", re-use the referenced message name.
    if (msgname.startsWith('=')) {
      key = msgname.substr(1);
      msgname = i18n[key];
    }

    // For "$foo", calculate the message name.
    if (msgname.startsWith('$')) {
      msgname = thunk(node.getAttribute(msgname.substr(1)) + '_' + key);
    }

    // Finally load the message.
    const msg = this.get(msgname);
    if (attr == '_') {
      node.textContent = msg;
    } else {
      node.setAttribute(attr, msg);
    }
  }
};
// SOURCE FILE: libdot/js/lib_preference_manager.js
// Copyright 2012 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Constructor for lib.PreferenceManager objects.
 *
 * These objects deal with persisting changes to stable storage and notifying
 * consumers when preferences change.
 *
 * It is intended that the backing store could be something other than HTML5
 * storage, but there aren't any use cases at the moment.  In the future there
 * may be a chrome api to store sync-able name/value pairs, and we'd want
 * that.
 *
 * @param {!lib.Storage} storage The storage object to use as a backing
 *     store.
 * @param {string=} prefix The optional prefix to be used for all preference
 *     names.  The '/' character should be used to separate levels of hierarchy,
 *     if you're going to have that kind of thing.  If provided, the prefix
 *     should start with a '/'.  If not provided, it defaults to '/'.
 * @constructor
 */
lib.PreferenceManager = function(storage, prefix = '/') {
  this.storage = storage;
  this.storageObserver_ = this.onStorageChange_.bind(this);
  this.storage.addObserver(this.storageObserver_);

  this.trace = false;

  if (!prefix.endsWith('/')) {
    prefix += '/';
  }

  this.prefix = prefix;

  // Internal state for when we're doing a bulk import from JSON and we want
  // to elide redundant storage writes (for quota reasons).
  this.isImportingJson_ = false;

  /** @type {!Object<string, !lib.PreferenceManager.Record>} */
  this.prefRecords_ = {};
  this.globalObservers_ = [];
  this.prefixObservers_ = [];

  this.childFactories_ = {};

  // Map of list-name to {map of child pref managers}
  // As in...
  //
  //  this.childLists_ = {
  //    'profile-ids': {
  //      'one': PreferenceManager,
  //      'two': PreferenceManager,
  //      ...
  //    },
  //
  //    'frob-ids': {
  //      ...
  //    }
  //  }
  this.childLists_ = {};
};

/**
 * Used internally to indicate that the current value of the preference should
 * be taken from the default value defined with the preference.
 *
 * Equality tests against this value MUST use '===' or '!==' to be accurate.
 *
 * @type {symbol}
 */
lib.PreferenceManager.prototype.DEFAULT_VALUE = Symbol('DEFAULT_VALUE');

/**
 * An individual preference.
 *
 * These objects are managed by the PreferenceManager, you shouldn't need to
 * handle them directly.
 *
 * @param {string} name The name of the new preference (used for indexing).
 * @param {*} defaultValue The default value for this preference.
 * @constructor
 */
lib.PreferenceManager.Record = function(name, defaultValue) {
  this.name = name;
  this.defaultValue = defaultValue;
  this.currentValue = this.DEFAULT_VALUE;
  this.observers = [];
};

/**
 * A local copy of the DEFAULT_VALUE constant to make it less verbose.
 *
 * @type {symbol}
 */
lib.PreferenceManager.Record.prototype.DEFAULT_VALUE =
    lib.PreferenceManager.prototype.DEFAULT_VALUE;

/**
 * Register a callback to be invoked when this preference changes.
 *
 * @param {function(string, string, !lib.PreferenceManager)} observer The
 *     function to invoke.  It will receive the new value, the name of the
 *     preference, and a reference to the PreferenceManager as parameters.
 */
lib.PreferenceManager.Record.prototype.addObserver = function(observer) {
  this.observers.push(observer);
};

/**
 * Unregister an observer callback.
 *
 * @param {function(string, string, !lib.PreferenceManager)} observer A
 *     previously registered callback.
 */
lib.PreferenceManager.Record.prototype.removeObserver = function(observer) {
  const i = this.observers.indexOf(observer);
  if (i >= 0) {
    this.observers.splice(i, 1);
  }
};

/**
 * Fetch the value of this preference.
 *
 * @return {*} The value for this preference.
 */
lib.PreferenceManager.Record.prototype.get = function() {
  const result = this.currentValue === this.DEFAULT_VALUE ?
      this.defaultValue : this.currentValue;

  if (typeof this.defaultValue === 'object') {
    // We want to return a COPY of the value so that users can
    // modify the array or object without changing the value.
    return JSON.parse(JSON.stringify(result));
  }

  return result;
};

/**
 * Update prefix and reset and reload storage, then notify prefix observers, and
 * all pref observers with new values.
 *
 * @param {string} prefix
 * @param {function()=} callback Optional function to invoke when completed.
 */
lib.PreferenceManager.prototype.setPrefix = function(prefix, callback) {
  if (!prefix.endsWith('/')) {
    prefix += '/';
  }
  if (prefix === this.prefix) {
    if (callback) {
      callback();
    }
    return;
  }

  this.prefix = prefix;

  for (const name in this.prefRecords_) {
    this.prefRecords_[name].currentValue = this.DEFAULT_VALUE;
  }

  this.readStorage(() => {
    for (const o of this.prefixObservers_) {
      o(this.prefix, this);
    }
    this.notifyAll();
    if (callback) {
      callback();
    }
  });
};

/**
 * Read the backing storage for these preferences.
 *
 * You should do this once at initialization time to prime the local cache
 * of preference values.  The preference manager will monitor the backing
 * storage for changes, so you should not need to call this more than once.
 *
 * This function recursively reads storage for all child preference managers as
 * well.
 *
 * This function is asynchronous, if you need to read preference values, you
 * *must* wait for the callback.
 *
 * @param {function()=} callback Optional function to invoke when the read
 *     has completed.
 */
lib.PreferenceManager.prototype.readStorage = function(callback = undefined) {
  let pendingChildren = 0;

  function onChildComplete() {
    if (--pendingChildren == 0 && callback) {
      callback();
    }
  }

  const keys = Object.keys(this.prefRecords_).map((el) => this.prefix + el);

  if (this.trace) {
    console.log('Preferences read: ' + this.prefix);
  }

  this.storage.getItems(keys).then((items) => {
      const prefixLength = this.prefix.length;

      for (const key in items) {
        const value = items[key];
        const name = key.substr(prefixLength);
        const needSync = (
            name in this.childLists_ &&
            (JSON.stringify(value) !=
             JSON.stringify(this.prefRecords_[name].currentValue)));

        this.prefRecords_[name].currentValue = value;

        if (needSync) {
          pendingChildren++;
          this.syncChildList(name, onChildComplete);
        }
      }

      if (pendingChildren == 0 && callback) {
        setTimeout(callback);
      }
    });
};

/**
 * Define a preference.
 *
 * This registers a name, default value, and onChange handler for a preference.
 *
 * @param {string} name The name of the preference.  This will be prefixed by
 *     the prefix of this PreferenceManager before written to local storage.
 * @param {string|number|boolean|!Object|!Array|null} value The default value of
 *     this preference.  Anything that can be represented in JSON is a valid
 *     default value.
 * @param {function(*, string, !lib.PreferenceManager)=} onChange A
 *     function to invoke when the preference changes.  It will receive the new
 *     value, the name of the preference, and a reference to the
 *     PreferenceManager as parameters.
 */
lib.PreferenceManager.prototype.definePreference = function(
    name, value, onChange = undefined) {

  let record = this.prefRecords_[name];
  if (record) {
    this.changeDefault(name, value);
  } else {
    record = this.prefRecords_[name] =
        new lib.PreferenceManager.Record(name, value);
  }

  if (onChange) {
    record.addObserver(onChange);
  }
};

/**
 * Define multiple preferences with a single function call.
 *
 * @param {!Array<*>} defaults An array of 3-element arrays.  Each three element
 *     array should contain the [key, value, onChange] parameters for a
 *     preference.
 */
lib.PreferenceManager.prototype.definePreferences = function(defaults) {
  for (let i = 0; i < defaults.length; i++) {
    this.definePreference(defaults[i][0], defaults[i][1], defaults[i][2]);
  }
};

/**
 * Define an ordered list of child preferences.
 *
 * Child preferences are different from just storing an array of JSON objects
 * in that each child is an instance of a preference manager.  This means you
 * can observe changes to individual child preferences, and get some validation
 * that you're not reading or writing to an undefined child preference value.
 *
 * @param {string} listName A name for the list of children.  This must be
 *     unique in this preference manager.  The listName will become a
 *     preference on this PreferenceManager used to store the ordered list of
 *     child ids.  It is also used in get/add/remove operations to identify the
 *     list of children to operate on.
 * @param {function(!lib.PreferenceManager, string)} childFactory A function
 *     that will be used to generate instances of these children.  The factory
 *     function will receive the parent lib.PreferenceManager object and a
 *     unique id for the new child preferences.
 */
lib.PreferenceManager.prototype.defineChildren = function(
    listName, childFactory) {

  // Define a preference to hold the ordered list of child ids.
  this.definePreference(listName, [],
                        this.onChildListChange_.bind(this, listName));
  this.childFactories_[listName] = childFactory;
  this.childLists_[listName] = {};
};

/**
 * Register a callback to be invoked when PreferenceManager prefix changes.
 *
 * @param {function(string, !lib.PreferenceManager)} observer The
 *     function to invoke.  It will receive the new prefix, and a reference
 *     to the PreferenceManager as parameters.
 */
lib.PreferenceManager.prototype.addPrefixObserver = function(observer) {
  this.prefixObservers_.push(observer);
};

/**
 * Unregister an observer callback.
 *
 * @param {function(string, !lib.PreferenceManager)} observer A
 *     previously registered callback.
 */
lib.PreferenceManager.prototype.removePrefixObserver = function(observer) {
  const i = this.prefixObservers_.indexOf(observer);
  if (i >= 0) {
    this.prefixObservers_.splice(i, 1);
  }
};

/**
 * Register to observe preference changes.
 *
 * @param {string} name The name of preference you wish to observe..
 * @param {function(*, string, !lib.PreferenceManager)} observer The callback.
 */
lib.PreferenceManager.prototype.addObserver = function(name, observer) {
  if (!(name in this.prefRecords_)) {
    throw new Error(`Unknown preference: ${name}`);
  }

  this.prefRecords_[name].addObserver(observer);
};

/**
 * Register to observe preference changes.
 *
 * @param {?function()} global A callback that will happen for every preference.
 *     Pass null if you don't need one.
 * @param {!Object} map A map of preference specific callbacks.  Pass null if
 *     you don't need any.
 */
lib.PreferenceManager.prototype.addObservers = function(global, map) {
  if (global && typeof global != 'function') {
    throw new Error('Invalid param: globals');
  }

  if (global) {
    this.globalObservers_.push(global);
  }

  if (!map) {
    return;
  }

  for (const name in map) {
    this.addObserver(name, map[name]);
  }
};

/**
 * Remove preference observer.
 *
 * @param {string} name The name of preference you wish to stop observing.
 * @param {function(*, string, !lib.PreferenceManager)} observer The observer to
 *     remove.
 */
lib.PreferenceManager.prototype.removeObserver = function(name, observer) {
  if (!(name in this.prefRecords_)) {
    throw new Error(`Unknown preference: ${name}`);
  }

  this.prefRecords_[name].removeObserver(observer);
};

/**
 * Dispatch the change observers for all known preferences.
 *
 * It may be useful to call this after readStorage completes, in order to
 * get application state in sync with user preferences.
 *
 * This can be used if you've changed a preference manager out from under
 * a live object, for example when switching to a different prefix.
 */
lib.PreferenceManager.prototype.notifyAll = function() {
  for (const name in this.prefRecords_) {
    this.notifyChange_(name);
  }
};

/**
 * Notify the change observers for a given preference.
 *
 * @param {string} name The name of the preference that changed.
 */
lib.PreferenceManager.prototype.notifyChange_ = function(name) {
  const record = this.prefRecords_[name];
  if (!record) {
    throw new Error('Unknown preference: ' + name);
  }

  const currentValue = record.get();

  for (let i = 0; i < this.globalObservers_.length; i++) {
    this.globalObservers_[i](name, currentValue);
  }

  for (let i = 0; i < record.observers.length; i++) {
    record.observers[i](currentValue, name, this);
  }
};

// Suppress linter for bug
// https://github.com/gajus/eslint-plugin-jsdoc/issues/932
//
// eslint-disable-next-line jsdoc/require-returns-check
/**
 * Generate a random, 4-digit hex identifier.
 *
 * @param {!Array<string>=} existingIds A list of existing ids to avoid.
 * @param {?string=} prefix Optional prefix to include in the id.
 * @return {string} The id.
 */
lib.PreferenceManager.newRandomId = function(
    existingIds = [], prefix = undefined) {
  // Pick a random, unique 4-digit hex identifier for the new profile.
  while (true) {
    let id = lib.f.randomInt(1, 0xffff).toString(16);
    id = lib.f.zpad(id, 4);
    if (prefix) {
      id = `${prefix}:${id}`;
    }
    if (existingIds.indexOf(id) === -1) {
      return id;
    }
  }
};

/**
 * Create a new child PreferenceManager for the given child list.
 *
 * The optional hint parameter is an opaque prefix added to the auto-generated
 * unique id for this child.  Your child factory can parse out the prefix
 * and use it.
 *
 * @param {string} listName The child list to create the new instance from.
 * @param {?string=} prefix Optional prefix to include in the child id.
 * @param {string=} id Optional id to override the generated id.
 * @return {!lib.PreferenceManager} The new child preference manager.
 */
lib.PreferenceManager.prototype.createChild = function(
    listName, prefix = undefined, id = undefined) {
  const ids = /** @type {!Array<string>} */ (this.get(listName));

  if (id) {
    if (ids.indexOf(id) != -1) {
      throw new Error('Duplicate child: ' + listName + ': ' + id);
    }

  } else {
    id = lib.PreferenceManager.newRandomId(ids, prefix);
  }

  const childManager = this.childFactories_[listName](this, id);
  childManager.trace = this.trace;
  childManager.resetAll();

  this.childLists_[listName][id] = childManager;

  ids.push(id);
  this.set(listName, ids, undefined, !this.isImportingJson_);

  return childManager;
};

/**
 * Remove a child preferences instance.
 *
 * Removes a child preference manager and clears any preferences stored in it.
 *
 * @param {string} listName The name of the child list containing the child to
 *     remove.
 * @param {string} id The child ID.
 */
lib.PreferenceManager.prototype.removeChild = function(listName, id) {
  const prefs = this.getChild(listName, id);
  prefs.resetAll();

  const ids = /** @type {!Array<string>} */ (this.get(listName));
  const i = ids.indexOf(id);
  if (i != -1) {
    ids.splice(i, 1);
    this.set(listName, ids, undefined, !this.isImportingJson_);
  }

  delete this.childLists_[listName][id];
};

/**
 * Return a child PreferenceManager instance for a given id.
 *
 * If the child list or child id is not known this will return the specified
 * default value or throw an exception if no default value is provided.
 *
 * @param {string} listName The child list to look in.
 * @param {string} id The child ID.
 * @param {!lib.PreferenceManager=} defaultValue The value to return if the
 *     child is not found.
 * @return {!lib.PreferenceManager} The specified child PreferenceManager.
 */
lib.PreferenceManager.prototype.getChild = function(
    listName, id, defaultValue = undefined) {
  if (!(listName in this.childLists_)) {
    throw new Error('Unknown child list: ' + listName);
  }

  const childList = this.childLists_[listName];
  if (!(id in childList)) {
    if (defaultValue === undefined) {
      throw new Error('Unknown "' + listName + '" child: ' + id);
    }

    return defaultValue;
  }

  return childList[id];
};

/**
 * Synchronize a list of child PreferenceManagers instances with the current
 * list stored in prefs.
 *
 * This will instantiate any missing managers and read current preference values
 * from storage.  Any active managers that no longer appear in preferences will
 * be deleted.
 *
 * @param {string} listName The child list to synchronize.
 * @param {function()=} callback Function to invoke when the sync finishes.
 */
lib.PreferenceManager.prototype.syncChildList = function(
    listName, callback = undefined) {
  let pendingChildren = 0;
  function onChildStorage() {
    if (--pendingChildren == 0 && callback) {
      callback();
    }
  }

  // The list of child ids that we *should* have a manager for.
  const currentIds = /** @type {!Array<string>} */ (this.get(listName));

  // The known managers at the start of the sync.  Any manager still in this
  // list at the end should be discarded.
  const oldIds = Object.keys(this.childLists_[listName]);

  for (let i = 0; i < currentIds.length; i++) {
    const id = currentIds[i];

    const managerIndex = oldIds.indexOf(id);
    if (managerIndex >= 0) {
      oldIds.splice(managerIndex, 1);
    }

    if (!this.childLists_[listName][id]) {
      const childManager = this.childFactories_[listName](this, id);
      if (!childManager) {
        console.warn('Unable to restore child: ' + listName + ': ' + id);
        continue;
      }

      childManager.trace = this.trace;
      this.childLists_[listName][id] = childManager;
      pendingChildren++;
      childManager.readStorage(onChildStorage);
    }
  }

  for (let i = 0; i < oldIds.length; i++) {
    delete this.childLists_[listName][oldIds[i]];
  }

  if (!pendingChildren && callback) {
    setTimeout(callback);
  }
};

/**
 * Reset a preference to its default state.
 *
 * This will dispatch the onChange handler if the preference value actually
 * changes.
 *
 * @param {string} name The preference to reset.
 */
lib.PreferenceManager.prototype.reset = function(name) {
  const record = this.prefRecords_[name];
  if (!record) {
    throw new Error('Unknown preference: ' + name);
  }

  this.storage.removeItem(this.prefix + name);

  if (record.currentValue !== this.DEFAULT_VALUE) {
    record.currentValue = this.DEFAULT_VALUE;
    this.notifyChange_(name);
  }
};

/**
 * Reset all preferences back to their default state.
 */
lib.PreferenceManager.prototype.resetAll = function() {
  const changed = [];

  for (const listName in this.childLists_) {
    const childList = this.childLists_[listName];
    for (const id in childList) {
      childList[id].resetAll();
    }
  }

  for (const name in this.prefRecords_) {
    if (this.prefRecords_[name].currentValue !== this.DEFAULT_VALUE) {
      this.prefRecords_[name].currentValue = this.DEFAULT_VALUE;
      changed.push(name);
    }
  }

  const keys = Object.keys(this.prefRecords_).map(function(el) {
      return this.prefix + el;
  }.bind(this));

  this.storage.removeItems(keys);

  changed.forEach(this.notifyChange_.bind(this));
};

/**
 * Return true if two values should be considered not-equal.
 *
 * If both values are the same scalar type and compare equal this function
 * returns false (no difference), otherwise return true.
 *
 * This is used in places where we want to check if a preference has changed.
 * Compare complex values (objects or arrays) using JSON serialization. Objects
 * with more than a single primitive property may not have the same JSON
 * serialization, but for our purposes with default objects, this is OK.
 *
 * @param {*} a A value to compare.
 * @param {*} b A value to compare.
 * @return {boolean} Whether the two are not equal.
 */
lib.PreferenceManager.prototype.diff = function(a, b) {
  // If the types are different.
  if ((typeof a) !== (typeof b)) {
    return true;
  }

  // Or if the type is not a simple primitive one.
  if (!(/^(undefined|boolean|number|string)$/.test(typeof a))) {
    // Special case the null object.
    if (a === null && b === null) {
      return false;
    } else {
      return JSON.stringify(a) !== JSON.stringify(b);
    }
  }

  // Do a normal compare for primitive types.
  return a !== b;
};

/**
 * Change the default value of a preference.
 *
 * This is useful when subclassing preference managers.
 *
 * The function does not alter the current value of the preference, unless
 * it has the old default value.  When that happens, the change observers
 * will be notified.
 *
 * @param {string} name The name of the parameter to change.
 * @param {*} newValue The new default value for the preference.
 */
lib.PreferenceManager.prototype.changeDefault = function(name, newValue) {
  const record = this.prefRecords_[name];
  if (!record) {
    throw new Error('Unknown preference: ' + name);
  }

  if (!this.diff(record.defaultValue, newValue)) {
    // Default value hasn't changed.
    return;
  }

  if (record.currentValue !== this.DEFAULT_VALUE) {
    // This pref has a specific value, just change the default and we're done.
    record.defaultValue = newValue;
    return;
  }

  record.defaultValue = newValue;

  this.notifyChange_(name);
};

/**
 * Change the default value of multiple preferences.
 *
 * @param {!Object} map A map of name -> value pairs specifying the new default
 *     values.
 */
lib.PreferenceManager.prototype.changeDefaults = function(map) {
  for (const key in map) {
    this.changeDefault(key, map[key]);
  }
};

/**
 * Set a preference to a specific value.
 *
 * This will dispatch the onChange handler if the preference value actually
 * changes.
 *
 * @param {string} name The preference to set.
 * @param {*} newValue The value to set.  Anything that can be represented in
 *     JSON is a valid value.
 * @param {function()=} onComplete Callback when the set call completes.
 * @param {boolean=} saveToStorage Whether to commit the change to the backing
 *     storage or only the in-memory record copy.
 * @return {!Promise<void>} Promise which resolves once all observers are
 *     notified.
 */
lib.PreferenceManager.prototype.set = function(
    name, newValue, onComplete = undefined, saveToStorage = true) {
  const record = this.prefRecords_[name];
  if (!record) {
    throw new Error('Unknown preference: ' + name);
  }

  const oldValue = record.get();

  if (!this.diff(oldValue, newValue)) {
    return Promise.resolve();
  }

  if (this.diff(record.defaultValue, newValue)) {
    record.currentValue = newValue;
    if (saveToStorage) {
      this.storage.setItem(this.prefix + name, newValue).then(onComplete);
    }
  } else {
    record.currentValue = this.DEFAULT_VALUE;
    if (saveToStorage) {
      this.storage.removeItem(this.prefix + name).then(onComplete);
    }
  }

  // We need to manually send out the notification on this instance.  If we
  // The storage event won't fire a notification because we've already changed
  // the currentValue, so it won't see a difference.  If we delayed changing
  // currentValue until the storage event, a pref read immediately after a write
  // would return the previous value.
  //
  // The notification is async so clients don't accidentally depend on
  // a synchronous notification.
  return Promise.resolve().then(() => {
    this.notifyChange_(name);
  });
};

/**
 * Get the value of a preference.
 *
 * @param {string} name The preference to get.
 * @return {*} The preference's value.
 */
lib.PreferenceManager.prototype.get = function(name) {
  const record = this.prefRecords_[name];
  if (!record) {
    throw new Error('Unknown preference: ' + name);
  }

  return record.get();
};

/**
 * Get the default value of a preference.
 *
 * @param {string} name The preference to get.
 * @return {*} The preference's default value.
 */
lib.PreferenceManager.prototype.getDefault = function(name) {
  const record = this.prefRecords_[name];
  if (!record) {
    throw new Error(`Unknown preference: ${name}`);
  }

  return record.defaultValue;
};

/**
 * Get the boolean value of a preference.
 *
 * @param {string} name The preference to get.
 * @return {boolean}
 */
lib.PreferenceManager.prototype.getBoolean = function(name) {
  const result = this.get(name);
  lib.assert(typeof result == 'boolean');
  return result;
};

/**
 * Get the number value of a preference.
 *
 * @param {string} name The preference to get.
 * @return {number}
 */
lib.PreferenceManager.prototype.getNumber = function(name) {
  const result = this.get(name);
  lib.assert(typeof result == 'number');
  return result;
};

/**
 * Get the string value of a preference.
 *
 * @param {string} name The preference to get.
 * @return {string}
 */
lib.PreferenceManager.prototype.getString = function(name) {
  const result = this.get(name);
  lib.assert(typeof result == 'string');
  return result;
};

/**
 * Return all non-default preferences as a JSON object.
 *
 * This includes any nested preference managers as well.
 *
 * @return {!Object} The JSON preferences.
 */
lib.PreferenceManager.prototype.exportAsJson = function() {
  const rv = {};

  for (const name in this.prefRecords_) {
    if (name in this.childLists_) {
      rv[name] = [];
      const childIds = /** @type {!Array<string>} */ (this.get(name));
      for (let i = 0; i < childIds.length; i++) {
        const id = childIds[i];
        rv[name].push({id: id, json: this.getChild(name, id).exportAsJson()});
      }

    } else {
      const record = this.prefRecords_[name];
      if (record.currentValue != this.DEFAULT_VALUE) {
        rv[name] = record.currentValue;
      }
    }
  }

  return rv;
};

/**
 * Import a JSON blob of preferences previously generated with exportAsJson.
 *
 * This will create nested preference managers as well.
 *
 * @param {!Object} json The JSON settings to import.
 * @return {!Promise<void>} A promise that resolves once the import completes.
 */
lib.PreferenceManager.prototype.importFromJson = async function(json) {
  this.isImportingJson_ = true;

  // Clear the current prefernces back to their defaults, and throw away any
  // children.  We'll recreate them if needed.
  for (const listName in this.childLists_) {
    const childList = this.childLists_[listName];
    for (const id in childList) {
      this.removeChild(listName, id);
    }
  }
  this.resetAll();

  for (const name in json) {
    if (name in this.childLists_) {
      const childList = json[name];
      const ids = [];
      for (let i = 0; i < childList.length; i++) {
        const id = childList[i].id;
        ids.push(id);

        let childPrefManager = this.childLists_[name][id];
        if (!childPrefManager) {
          childPrefManager = this.createChild(name, null, id);
        }

        await childPrefManager.importFromJson(childList[i].json);
      }
      // Update the list of children now that we've finished creating them.
      await this.set(name, ids);
    } else {
      await this.set(name, json[name]);
    }
  }

  this.isImportingJson_ = false;
};

/**
 * Called when one of the child list preferences changes.
 *
 * @param {string} listName The child list to synchronize.
 */
lib.PreferenceManager.prototype.onChildListChange_ = function(listName) {
  this.syncChildList(listName);
};

/**
 * Called when a key in the storage changes.
 *
 * @param {!Object} map Dictionary of changed settings.
 */
lib.PreferenceManager.prototype.onStorageChange_ = function(map) {
  for (const key in map) {
    if (this.prefix) {
      if (key.lastIndexOf(this.prefix, 0) != 0) {
        continue;
      }
    }

    const name = key.substr(this.prefix.length);

    if (!(name in this.prefRecords_)) {
      // Sometimes we'll get notified about prefs that are no longer defined.
      continue;
    }

    const record = this.prefRecords_[name];

    const newValue = map[key].newValue;
    let currentValue = record.currentValue;
    if (currentValue === record.DEFAULT_VALUE) {
      currentValue = undefined;
    }

    if (this.diff(currentValue, newValue)) {
      if (typeof newValue == 'undefined' || newValue === null) {
        record.currentValue = record.DEFAULT_VALUE;
      } else {
        record.currentValue = newValue;
      }

      this.notifyChange_(name);
    }
  }
};
// SOURCE FILE: libdot/js/lib_resource.js
// Copyright 2012 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Storage for canned resources.
 *
 * These are usually non-JavaScript things that are collected during a build
 * step and converted into a series of 'lib.resource.add(...)' calls.  See
 * the "@resource" directive from libdot/bin/concat for the canonical use
 * case.
 *
 * This is global storage, so you should prefix your resource names to avoid
 * collisions.
 */
lib.resource = {
  resources_: {},
};

/** @typedef {{type: string, name: string, data: *}} */
lib.resource.ResourceRecord;

/**
 * Add a resource.
 *
 * @param {string} name A name for the resource.  You should prefix this to
 *     avoid collisions with resources from a shared library.
 * @param {string} type A mime type for the resource, or "raw" if not
 *     applicable.
 * @param {*} data The value of the resource.
 */
lib.resource.add = function(name, type, data) {
  lib.resource.resources_[name] = {
    type: type,
    name: name,
    data: data,
  };
};

/**
 * Retrieve a resource record.
 *
 * The resource data is stored on the "data" property of the returned object.
 *
 * @param {string} name The name of the resource to get.
 * @param {!lib.resource.ResourceRecord=} defaultValue The value to return if
 *     the resource is not defined.
 * @return {!lib.resource.ResourceRecord} The matching resource if it exists.
 */
lib.resource.get = function(name, defaultValue) {
  if (!(name in lib.resource.resources_)) {
    lib.assert(defaultValue !== undefined);
    return defaultValue;
  }

  return lib.resource.resources_[name];
};

/**
 * @param {string} name The name of the resource to get.
 * @return {string} The resource data.
 */
lib.resource.getText = function(name) {
  const resource = lib.resource.resources_[name];
  if (resource === undefined) {
    throw new Error(`Error: Resource "${name}" does not exist`);
  }
  if (!resource.type.startsWith('text/') &&
      !resource.type.startsWith('image/svg')) {
    throw new Error(`Error: Resource "${name}" is not of type string`);
  }

  return String(lib.resource.resources_[name].data);
};

/**
 * Retrieve resource data.
 *
 * @param {string} name The name of the resource to get.
 * @param {*=} defaultValue The value to return if the resource is not defined.
 * @return {*} The resource data.
 */
lib.resource.getData = function(name, defaultValue) {
  if (!(name in lib.resource.resources_)) {
    return defaultValue;
  }

  return lib.resource.resources_[name].data;
};

/**
 * Retrieve resource as a data: url.
 *
 * @param {string} name The name of the resource to get.
 * @param {!lib.resource.ResourceRecord=} defaultValue The value to return if
 *     the resource is not defined.
 * @return {string} A data: url encoded version of the resource.
 */
lib.resource.getDataUrl = function(name, defaultValue) {
  const resource = lib.resource.get(name, defaultValue);
  return 'data:' + resource.type + ',' + resource.data;
};
// SOURCE FILE: libdot/js/lib_storage.js
// Copyright 2012 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for implementations of persistent, possibly cloud-backed
 * storage.
 *
 * @interface
 */
lib.Storage = function() {};

/**
 * Register a function to observe storage changes.
 *
 * @param {function(!Object<string, !StorageChange>)} callback The function to
 *     invoke when the storage changes.
 */
lib.Storage.prototype.addObserver = function(callback) {};

/**
 * Unregister a change observer.
 *
 * @param {function(!Object<string, !StorageChange>)} callback A previously
 *     registered callback.
 */
lib.Storage.prototype.removeObserver = function(callback) {};

/**
 * Delete everything in this storage.
 */
lib.Storage.prototype.clear = async function() {};

/**
 * Return the current value of a storage item.
 *
 * @param {string} key The key to look up.
 * @return {!Promise<*>} A promise resolving to the requested item.
 */
lib.Storage.prototype.getItem = async function(key) {};

/**
 * Fetch the values of multiple storage items.
 *
 * @param {?Array<string>} keys The keys to look up.  Pass null for all keys.
 * @return {!Promise<!Object<string, *>>} A promise resolving to the requested
 *     items.
 */
lib.Storage.prototype.getItems = async function(keys) {};

/**
 * Set a value in storage.
 *
 * You don't have to wait for the set to complete in order to read the value
 * since the local cache is updated synchronously.
 *
 * @param {string} key The key for the value to be stored.
 * @param {*} value The value to be stored.  Anything that can be serialized
 *     with JSON is acceptable.
 */
lib.Storage.prototype.setItem = async function(key, value) {};

/**
 * Set multiple values in storage.
 *
 * You don't have to wait for the set to complete in order to read the value
 * since the local cache is updated synchronously.
 *
 * @param {!Object} obj A map of key/values to set in storage.
 */
lib.Storage.prototype.setItems = async function(obj) {};

/**
 * Remove an item from storage.
 *
 * @param {string} key The key to be removed.
 */
lib.Storage.prototype.removeItem = async function(key) {};

/**
 * Remove multiple items from storage.
 *
 * @param {!Array<string>} keys The keys to be removed.
 */
lib.Storage.prototype.removeItems = async function(keys) {};

/**
 * Create the set of changes between two states.
 *
 * This is used to synthesize the equivalent of Chrome's StorageEvent for use
 * by our stub APIs and testsuites.  We expect Chrome's StorageEvent to also
 * match the web's Storage API & window.onstorage events.
 *
 * @param {!Object<string, *>} oldStorage The old storage state.
 * @param {!Object<string, *>} newStorage The new storage state.
 * @return {!Object<string, {oldValue: ?, newValue: ?}>} The changes.
 */
lib.Storage.generateStorageChanges = function(oldStorage, newStorage) {
  const changes = {};

  // See what's changed.
  for (const key in newStorage) {
    const newValue = newStorage[key];
    if (oldStorage.hasOwnProperty(key)) {
      // Key has been updated.
      const oldValue = oldStorage[key];
      if (oldValue !== newValue) {
        changes[key] = {oldValue, newValue};
      }
    } else {
      // Key has been added.
      changes[key] = {newValue};
    }
  }

  // See what's deleted.
  for (const key in oldStorage) {
    if (!newStorage.hasOwnProperty(key)) {
      changes[key] = {oldValue: oldStorage[key]};
    }
  }

  return changes;
};
// SOURCE FILE: libdot/js/lib_storage_chrome.js
// Copyright 2012 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * chrome.storage based class with an async interface that is interchangeable
 * with other lib.Storage.* implementations.
 *
 * @param {!StorageArea} storage The backing storage.
 * @implements {lib.Storage}
 * @constructor
 */
lib.Storage.Chrome = function(storage) {
  this.storage_ = storage;
  this.observers_ = [];

  storage.onChanged.addListener(this.onChanged_.bind(this));
};

/**
 * Called by the storage implementation when the storage is modified.
 *
 * @param {!Object<string, !StorageChange>} changes Object mapping each key that
 *     changed to its corresponding StorageChange for that item.
 */
lib.Storage.Chrome.prototype.onChanged_ = function(changes) {
  this.observers_.forEach((o) => o(changes));
};

/**
 * Register a function to observe storage changes.
 *
 * @param {function(!Object<string, !StorageChange>)} callback The function to
 *     invoke when the storage changes.
 * @override
 */
lib.Storage.Chrome.prototype.addObserver = function(callback) {
  this.observers_.push(callback);
};

/**
 * Unregister a change observer.
 *
 * @param {function(!Object<string, !StorageChange>)} callback A previously
 *     registered callback.
 * @override
 */
lib.Storage.Chrome.prototype.removeObserver = function(callback) {
  const i = this.observers_.indexOf(callback);
  if (i != -1) {
    this.observers_.splice(i, 1);
  }
};

/**
 * Delete everything in this storage.
 *
 * @override
 */
lib.Storage.Chrome.prototype.clear = async function() {
  return new Promise((resolve) => {
    this.storage_.clear(resolve);
  });
};

/**
 * Return the current value of a storage item.
 *
 * @param {string} key The key to look up.
 * @override
 */
lib.Storage.Chrome.prototype.getItem = async function(key) {
  return this.getItems([key]).then((items) => items[key]);
};

/**
 * Fetch the values of multiple storage items.
 *
 * @param {?Array<string>} keys The keys to look up.  Pass null for all keys.
 * @override
 */
lib.Storage.Chrome.prototype.getItems = async function(keys) {
  return new Promise((resolve) => {
    this.storage_.get(keys, resolve);
  });
};

/**
 * Set a value in storage.
 *
 * @param {string} key The key for the value to be stored.
 * @param {*} value The value to be stored.  Anything that can be serialized
 *     with JSON is acceptable.
 * @override
 */
lib.Storage.Chrome.prototype.setItem = async function(key, value) {
  return new Promise((resolve) => {
    const onComplete = () => {
      const err = lib.f.lastError();
      if (err) {
        // Doesn't seem to be any better way of handling this.
        // https://crbug.com/764759
        if (err.indexOf('MAX_WRITE_OPERATIONS')) {
          console.warn(`Will retry '${key}' save after exceeding quota:`, err);
          setTimeout(() => this.setItem(key, value).then(onComplete), 1000);
          return;
        } else {
          console.error(`Unknown runtime error: ${err}`);
        }
      }

      resolve();
    };

    this.setItems({[key]: value}).then(onComplete);
  });
};

/**
 * Set multiple values in storage.
 *
 * @param {!Object} obj A map of key/values to set in storage.
 * @override
 */
lib.Storage.Chrome.prototype.setItems = async function(obj) {
  return new Promise((resolve) => {
    this.storage_.set(obj, resolve);
  });
};

/**
 * Remove an item from storage.
 *
 * @param {string} key The key to be removed.
 * @override
 */
lib.Storage.Chrome.prototype.removeItem = async function(key) {
  return this.removeItems([key]);
};

/**
 * Remove multiple items from storage.
 *
 * @param {!Array<string>} keys The keys to be removed.
 * @override
 */
lib.Storage.Chrome.prototype.removeItems = async function(keys) {
  return new Promise((resolve) => {
    this.storage_.remove(keys, resolve);
  });
};
// SOURCE FILE: libdot/js/lib_storage_local.js
// Copyright 2012 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * window.localStorage based class with an async interface that is
 * interchangeable with other lib.Storage.* implementations.
 *
 * @param {!Storage=} storage The backing storage.
 * @implements {lib.Storage}
 * @constructor
 */
lib.Storage.Local = function(storage = undefined) {
  this.observers_ = [];
  /** @type {!Storage} */
  this.storage_ = storage ? storage : lib.notNull(globalThis.localStorage);
  // Closure thinks all addEventListener calls take Events.
  globalThis.addEventListener(
      'storage',
      /** @type {function(!Event)} */ (this.onStorage_.bind(this)));
};

/**
 * Returns parsed JSON, or original value if JSON.parse fails.
 *
 * @param {?string} jsonString The string to parse.
 * @return {*}
 */
lib.Storage.Local.prototype.parseJson_ = function(jsonString) {
  if (jsonString !== null) {
    try {
      return JSON.parse(jsonString);
    } catch (e) {
      // Ignore and return jsonString.
    }
  }
  return jsonString;
};

/**
 * Called by the storage implementation when the storage is modified.
 *
 * @param {!StorageEvent} e The setting that has changed.
 */
lib.Storage.Local.prototype.onStorage_ = function(e) {
  if (e.storageArea != this.storage_) {
    return;
  }

  const o = {};
  o[e.key] = {
    oldValue: this.parseJson_(e.oldValue),
    newValue: this.parseJson_(e.newValue),
  };

  for (let i = 0; i < this.observers_.length; i++) {
    this.observers_[i](o);
  }
};

/**
 * Register a function to observe storage changes.
 *
 * @param {function(!Object)} callback The function to invoke when the storage
 *     changes.
 * @override
 */
lib.Storage.Local.prototype.addObserver = function(callback) {
  this.observers_.push(callback);
};

/**
 * Unregister a change observer.
 *
 * @param {function(!Object)} callback A previously registered callback.
 * @override
 */
lib.Storage.Local.prototype.removeObserver = function(callback) {
  const i = this.observers_.indexOf(callback);
  if (i != -1) {
    this.observers_.splice(i, 1);
  }
};

/**
 * Delete everything in this storage.
 *
 * @override
 */
lib.Storage.Local.prototype.clear = async function() {
  this.storage_.clear();

  // Force deferment for the standard API.
  await 0;
};

/**
 * Return the current value of a storage item.
 *
 * @param {string} key The key to look up.
 * @override
 */
lib.Storage.Local.prototype.getItem = async function(key) {
  return this.getItems([key]).then((items) => items[key]);
};

/**
 * Fetch the values of multiple storage items.
 *
 * @param {?Array<string>} keys The keys to look up.  Pass null for all keys.
 * @override
 */
lib.Storage.Local.prototype.getItems = async function(keys) {
  const rv = {};
  if (!keys) {
    keys = [];
    for (let i = 0; i < this.storage_.length; i++) {
      keys.push(this.storage_.key(i));
    }
  }

  for (const key of keys) {
    const value = this.storage_.getItem(key);
    if (typeof value == 'string') {
      rv[key] = this.parseJson_(value);
    }
  }

  // Force deferment for the standard API.
  await 0;

  return rv;
};

/**
 * Set a value in storage.
 *
 * @param {string} key The key for the value to be stored.
 * @param {*} value The value to be stored.  Anything that can be serialized
 *     with JSON is acceptable.
 * @override
 */
lib.Storage.Local.prototype.setItem = async function(key, value) {
  return this.setItems({[key]: value});
};

/**
 * Set multiple values in storage.
 *
 * @param {!Object} obj A map of key/values to set in storage.
 * @override
 */
lib.Storage.Local.prototype.setItems = async function(obj) {
  for (const key in obj) {
    this.storage_.setItem(key, JSON.stringify(obj[key]));
  }

  // Force deferment for the standard API.
  await 0;
};

/**
 * Remove an item from storage.
 *
 * @param {string} key The key to be removed.
 * @override
 */
lib.Storage.Local.prototype.removeItem = async function(key) {
  return this.removeItems([key]);
};

/**
 * Remove multiple items from storage.
 *
 * @param {!Array<string>} keys The keys to be removed.
 * @override
 */
lib.Storage.Local.prototype.removeItems = async function(keys) {
  for (let i = 0; i < keys.length; i++) {
    this.storage_.removeItem(keys[i]);
  }

  // Force deferment for the standard API.
  await 0;
};
// SOURCE FILE: libdot/js/lib_storage_memory.js
// Copyright 2012 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * In-memory storage class with an async interface that is interchangeable with
 * other lib.Storage.* implementations.
 *
 * @constructor
 * @implements {lib.Storage}
 */
lib.Storage.Memory = function() {
  this.observers_ = [];
  this.storage_ = {};
};

/**
 * Register a function to observe storage changes.
 *
 * @param {function(!Object)} callback The function to invoke when the storage
 *     changes.
 * @override
 */
lib.Storage.Memory.prototype.addObserver = function(callback) {
  this.observers_.push(callback);
};

/**
 * Unregister a change observer.
 *
 * @param {function(!Object)} callback A previously registered callback.
 * @override
 */
lib.Storage.Memory.prototype.removeObserver = function(callback) {
  const i = this.observers_.indexOf(callback);
  if (i != -1) {
    this.observers_.splice(i, 1);
  }
};

/**
 * Update the internal storage state and generate change events for it.
 *
 * @param {!Object<string, *>} newStorage
 */
lib.Storage.Memory.prototype.update_ = async function(newStorage) {
  const changes = lib.Storage.generateStorageChanges(this.storage_, newStorage);
  this.storage_ = newStorage;

  // Force deferment for the standard API.
  await 0;

  // Don't bother notifying if there are no changes.
  if (Object.keys(changes).length) {
    this.observers_.forEach((o) => o(changes));
  }
};

/**
 * Delete everything in this storage.
 *
 * @override
 */
lib.Storage.Memory.prototype.clear = async function() {
  return this.update_({});
};

/**
 * Return the current value of a storage item.
 *
 * @param {string} key The key to look up.
 * @override
 */
lib.Storage.Memory.prototype.getItem = async function(key) {
  return this.getItems([key]).then((items) => items[key]);
};

/**
 * Fetch the values of multiple storage items.
 *
 * @param {?Array<string>} keys The keys to look up.  Pass null for all keys.
 * @override
 */
lib.Storage.Memory.prototype.getItems = async function(keys) {
  const rv = {};
  if (!keys) {
    keys = Object.keys(this.storage_);
  }

  keys.forEach((key) => {
    if (this.storage_.hasOwnProperty(key)) {
      rv[key] = this.storage_[key];
    }
  });

  // Force deferment for the standard API.
  await 0;

  return rv;
};

/**
 * Set a value in storage.
 *
 * @param {string} key The key for the value to be stored.
 * @param {*} value The value to be stored.  Anything that can be serialized
 *     with JSON is acceptable.
 * @override
 */
lib.Storage.Memory.prototype.setItem = async function(key, value) {
  return this.setItems({[key]: value});
};

/**
 * Set multiple values in storage.
 *
 * @param {!Object} obj A map of key/values to set in storage.
 * @override
 */
lib.Storage.Memory.prototype.setItems = async function(obj) {
  const newStorage = Object.assign({}, this.storage_);
  for (const key in obj) {
    // Normalize through JSON to mimic Local/Chrome backends.
    newStorage[key] = JSON.parse(JSON.stringify(obj[key]));
  }
  return this.update_(newStorage);
};

/**
 * Remove an item from storage.
 *
 * @param {string} key The key to be removed.
 * @override
 */
lib.Storage.Memory.prototype.removeItem = async function(key) {
  return this.removeItems([key]);
};

/**
 * Remove multiple items from storage.
 *
 * @param {!Array<string>} keys The keys to be removed.
 * @override
 */
lib.Storage.Memory.prototype.removeItems = async function(keys) {
  const newStorage = Object.assign({}, this.storage_);
  keys.forEach((key) => delete newStorage[key]);
  return this.update_(newStorage);
};
// SOURCE FILE: libdot/js/lib_storage_terminal_private.js
// Copyright 2019 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Storage implementation using chrome.terminalPrivate.
 *
 * @param {string=} prefPath Path of pref to read and update.  Uses
 *  'crostini.terminal_settings' by default.
 * @param {{
 *  getPrefs: function(!Array<string>, function(?Object)),
 *  setPrefs: function(!Object, function()),
 *  onPrefChanged: !ChromeEvent,
 * }=} storage
 * @constructor
 * @implements {lib.Storage}
 */
lib.Storage.TerminalPrivate = function(
    prefPath = 'crostini.terminal_settings',
    storage = chrome.terminalPrivate) {
  /**
   * @const
   * @private
   */
  this.prefPath_ = lib.notUndefined(prefPath);

  /**
   * @const
   * @private
   */
  this.observers_ = [];

  /**
   * Local cache of terminalPrivate.getPrefs().
   *
   * @private {!Object<string, *>}
   */
  this.prefValue_ = {};

  /**
   * We do async writes to terminalPrivate.setSettings to allow multiple sync
   * writes to be batched.  This array holds the list of pending resolve calls
   * that we'll invoke when the current write finishes.
   *
   * @private {!Array<function()>}
   */
  this.prefValueWriteToResolve_ = [];

  /** @type {boolean} */
  this.prefsLoaded_ = false;

  /** @const */
  this.storage_ = storage;

  this.storage_.onPrefChanged.addListener(
      this.onPrefChanged_.bind(this));
};

/**
 * Load the settings into our local cache.
 *
 * @return {!Promise<void>} Resolves when settings have been loaded.
 */
lib.Storage.TerminalPrivate.prototype.initCache_ = function() {
  return new Promise((resolve) => {
    // NB: This doesn't return Promise.resolve so we're guaranteed to have the
    // initCache_ call always return deferred execution.
    if (this.prefsLoaded_) {
      resolve();
      return;
    }

    this.storage_.getPrefs([this.prefPath_], (prefs) => {
      const err = lib.f.lastError();
      if (err) {
        console.error(err);
      } else {
        this.prefValue_ = lib.notNull(prefs[this.prefPath_]);
      }
      this.prefsLoaded_ = true;
      resolve();
    });
  });
};

/**
 * Called when pref changes.
 *
 * @param {!Object<string, *>} prefs
 * @private
 */
lib.Storage.TerminalPrivate.prototype.onPrefChanged_ = function(prefs) {
  const pref = /** @type {?Object<string, *>} */(prefs[this.prefPath_]);
  if (!pref || typeof pref !== 'object') {
    return;
  }
  // Check what is deleted.
  const changes = lib.Storage.generateStorageChanges(this.prefValue_, pref);
  this.prefValue_ = pref;

  // Don't bother notifying if there are no changes.
  if (Object.keys(changes).length) {
    setTimeout(() => {
      this.observers_.forEach((o) => o(changes));
    });
  }
};

/**
 * Set pref then run callback.  Writes are done async to allow multiple
 * concurrent calls to this function to be batched into a single write.
 *
 * @return {!Promise<void>} Resolves once the pref is set.
 * @private
 */
lib.Storage.TerminalPrivate.prototype.setPref_ = function() {
  lib.assert(this.prefsLoaded_);

  return new Promise((resolve) => {
    this.prefValueWriteToResolve_.push(resolve);
    if (this.prefValueWriteToResolve_.length > 1) {
      return;
    }

    // Force deferment to help coalesce.
    setTimeout(() => {
      this.storage_.setPrefs({[this.prefPath_]: this.prefValue_}, () => {
        const err = lib.f.lastError();
        if (err) {
          console.error(err);
        }
        // Resolve all the pending promises so their callbacks will be invoked
        // once this function returns.
        this.prefValueWriteToResolve_.forEach((r) => r());
        this.prefValueWriteToResolve_ = [];
      });
    });
  });
};

/**
 * Register a function to observe storage changes.
 *
 * @param {function(!Object)} callback The function to invoke when the storage
 *     changes.
 * @override
 */
lib.Storage.TerminalPrivate.prototype.addObserver = function(callback) {
  this.observers_.push(callback);
};

/**
 * Unregister a change observer.
 *
 * @param {function(!Object)} callback A previously registered callback.
 * @override
 */
lib.Storage.TerminalPrivate.prototype.removeObserver = function(callback) {
  const i = this.observers_.indexOf(callback);
  if (i !== -1) {
    this.observers_.splice(i, 1);
  }
};

/**
 * Update the internal storage state and generate change events for it.
 *
 * @param {!Object<string, *>} newStorage
 */
lib.Storage.TerminalPrivate.prototype.update_ = async function(newStorage) {
  const changes = lib.Storage.generateStorageChanges(
      this.prefValue_, newStorage);
  this.prefValue_ = newStorage;

  await this.setPref_();

  // Don't bother notifying if there are no changes.
  if (Object.keys(changes).length) {
    this.observers_.forEach((o) => o(changes));
  }
};

/**
 * Delete everything in this storage.
 *
 * @override
 */
lib.Storage.TerminalPrivate.prototype.clear = async function() {
  await this.initCache_();
  return this.update_({});
};

/**
 * Return the current value of a storage item.
 *
 * @param {string} key The key to look up.
 * @override
 */
lib.Storage.TerminalPrivate.prototype.getItem = async function(key) {
  await this.initCache_();
  return this.prefValue_[key];
};

/**
 * Fetch the values of multiple storage items.
 *
 * @param {?Array<string>} keys The keys to look up.  Pass null for all keys.
 * @override
 */
lib.Storage.TerminalPrivate.prototype.getItems = async function(keys) {
  await this.initCache_();

  const rv = {};
  if (!keys) {
    keys = Object.keys(this.prefValue_);
  }

  for (const key of keys) {
    if (this.prefValue_.hasOwnProperty(key)) {
      rv[key] = this.prefValue_[key];
    }
  }

  return rv;
};

/**
 * Set a value in storage.
 *
 * @param {string} key The key for the value to be stored.
 * @param {*} value The value to be stored.  Anything that can be serialized
 *     with JSON is acceptable.
 * @override
 */
lib.Storage.TerminalPrivate.prototype.setItem = async function(key, value) {
  return this.setItems({[key]: value});
};

/**
 * Set multiple values in storage.
 *
 * @param {!Object} obj A map of key/values to set in storage.
 * @override
 */
lib.Storage.TerminalPrivate.prototype.setItems = async function(obj) {
  await this.initCache_();
  return this.update_(Object.assign({}, this.prefValue_, obj));
};

/**
 * Remove an item from storage.
 *
 * @param {string} key The key to be removed.
 * @override
 */
lib.Storage.TerminalPrivate.prototype.removeItem = async function(key) {
  return this.removeItems([key]);
};

/**
 * Remove multiple items from storage.
 *
 * @param {!Array<string>} keys The keys to be removed.
 * @override
 */
lib.Storage.TerminalPrivate.prototype.removeItems = async function(keys) {
  await this.initCache_();
  const newStorage = Object.assign({}, this.prefValue_);
  keys.forEach((key) => delete newStorage[key]);
  return this.update_(newStorage);
};
lib.resource.add('libdot/changelog/version', 'text/plain',
'9.0.0'
);

lib.resource.add('libdot/changelog/date', 'text/plain',
'2022-02-24'
);

