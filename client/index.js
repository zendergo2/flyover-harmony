
const t = new hterm.Terminal();

const connection = new ServerConnection();
connection.onReceive((message) => {
	console.log("onReceive", message);
	LocalTerminalStringHandler(message);
});
t.onTerminalReady = function() {
	// Create a new terminal IO object and give it the foreground.
	// (The default IO object just prints warning messages about unhandled
	// things to the the JS console.)
	const io = t.io.push();

	io.onVTKeystroke = (str) => {
		// Do something useful with str here.
		// For example, Secure Shell forwards the string onto the NaCl plugin.
		// console.log("onVTKeystroke", str.charCodeAt(0));
		// LocalTerminalStringHandler(str);
		connection.send(str);
	};

	io.sendString = (str) => {
		// Just like a keystroke, except str was generated by the terminal itself.
		// For example, when the user pastes a string.
		// Most likely you'll do the same thing as onVTKeystroke.
		// console.log("sendString", str);
		// LocalTerminalStringHandler(str);
		connection.send(str);
	};

	io.onTerminalResize = (columns, rows) => {
		// React to size changes here.
		// Secure Shell pokes at NaCl, which eventually results in
		// some ioctls on the host.
	};

	// You can call io.push() to foreground a fresh io context, which can
	// be uses to give control of the terminal to something else.  When that
	// thing is complete, should call io.pop() to restore control to the
	// previous io object.
};

t.decorate(document.querySelector('#hterm'));
t.installKeyboard();


const LocalTerminalStringHandler = function(str) {
	if (str.endsWith('\r')) {
		t.io.println(str);
	} else {
		t.io.print(str);
	}
}